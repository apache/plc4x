/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

package model


import (
	"github.com/apache/plc4x/plc4go/internal/plc4go/spi/utils"
	"github.com/pkg/errors"
	"github.com/rs/zerolog/log"
)

	// Code generated by code-generation. DO NOT EDIT.


// The data-structure of this message
type MQTT_ControlPacket_CONNECT struct {
	*MQTT_ControlPacket
	RemainingLength uint8
	ProtocolName *MQTT_String
	ProtocolVersion uint8
	UserNameFlagSet bool
	PasswordFlagSet bool
	WillRetainFlagSet bool
	WillQosLevel uint8
	WillFlagSet bool
	CleanStartFlagSet bool
	KeepAlive uint16
	PropertyLength uint32
	Properties []*MQTT_Property
	ClientId *MQTT_String
	Username *MQTT_String
	Password *MQTT_String
}

// The corresponding interface
type IMQTT_ControlPacket_CONNECT interface {
	LengthInBytes() uint16
	LengthInBits() uint16
	Serialize(writeBuffer utils.WriteBuffer) error
}

///////////////////////////////////////////////////////////
// Accessors for discriminator values.
///////////////////////////////////////////////////////////
func (m *MQTT_ControlPacket_CONNECT) PacketType() MQTT_ControlPacketType {
	return MQTT_ControlPacketType_CONNECT
}


func (m *MQTT_ControlPacket_CONNECT) InitializeParent(parent *MQTT_ControlPacket) {
}

func NewMQTT_ControlPacket_CONNECT(remainingLength uint8, protocolName *MQTT_String, protocolVersion uint8, userNameFlagSet bool, passwordFlagSet bool, willRetainFlagSet bool, willQosLevel uint8, willFlagSet bool, cleanStartFlagSet bool, keepAlive uint16, propertyLength uint32, properties []*MQTT_Property, clientId *MQTT_String, username *MQTT_String, password *MQTT_String) *MQTT_ControlPacket {
	child := &MQTT_ControlPacket_CONNECT{
		RemainingLength: remainingLength,
		ProtocolName: protocolName,
		ProtocolVersion: protocolVersion,
		UserNameFlagSet: userNameFlagSet,
		PasswordFlagSet: passwordFlagSet,
		WillRetainFlagSet: willRetainFlagSet,
		WillQosLevel: willQosLevel,
		WillFlagSet: willFlagSet,
		CleanStartFlagSet: cleanStartFlagSet,
		KeepAlive: keepAlive,
		PropertyLength: propertyLength,
		Properties: properties,
		ClientId: clientId,
		Username: username,
		Password: password,
    	MQTT_ControlPacket: NewMQTT_ControlPacket(),
	}
	child.Child = child
	return child.MQTT_ControlPacket
}

func CastMQTT_ControlPacket_CONNECT(structType interface{}) *MQTT_ControlPacket_CONNECT {
	castFunc := func(typ interface{}) *MQTT_ControlPacket_CONNECT {
		if casted, ok := typ.(MQTT_ControlPacket_CONNECT); ok {
			return &casted
		}
		if casted, ok := typ.(*MQTT_ControlPacket_CONNECT); ok {
			return casted
		}
		if casted, ok := typ.(MQTT_ControlPacket); ok {
			return CastMQTT_ControlPacket_CONNECT(casted.Child)
		}
		if casted, ok := typ.(*MQTT_ControlPacket); ok {
			return CastMQTT_ControlPacket_CONNECT(casted.Child)
		}
		return nil
	}
	return castFunc(structType)
}

func (m *MQTT_ControlPacket_CONNECT) GetTypeName() string {
	return "MQTT_ControlPacket_CONNECT"
}

func (m *MQTT_ControlPacket_CONNECT) LengthInBits() uint16 {
	return m.LengthInBitsConditional(false)
}

func (m *MQTT_ControlPacket_CONNECT) LengthInBitsConditional(lastItem bool) uint16 {
	lengthInBits := uint16(m.ParentLengthInBits())

	// Reserved Field (reserved)
	lengthInBits += 4

	// Simple field (remainingLength)
	lengthInBits += 8;

	// Simple field (protocolName)
	lengthInBits += m.ProtocolName.LengthInBits()

	// Simple field (protocolVersion)
	lengthInBits += 8;

	// Simple field (userNameFlagSet)
	lengthInBits += 1;

	// Simple field (passwordFlagSet)
	lengthInBits += 1;

	// Simple field (willRetainFlagSet)
	lengthInBits += 1;

	// Simple field (willQosLevel)
	lengthInBits += 2;

	// Simple field (willFlagSet)
	lengthInBits += 1;

	// Simple field (cleanStartFlagSet)
	lengthInBits += 1;

	// Reserved Field (reserved)
	lengthInBits += 1

	// Simple field (keepAlive)
	lengthInBits += 16;

	// Simple field (propertyLength)
	lengthInBits += 32;

	// Array field
	if len(m.Properties) > 0 {
		for _, element := range m.Properties {
			lengthInBits += element.LengthInBits()
		}
	}

	// Simple field (clientId)
	lengthInBits += m.ClientId.LengthInBits()

	// Optional Field (username)
	if m.Username != nil {
		lengthInBits += (*m.Username).LengthInBits()
	}

	// Optional Field (password)
	if m.Password != nil {
		lengthInBits += (*m.Password).LengthInBits()
	}

	return lengthInBits
}


func (m *MQTT_ControlPacket_CONNECT) LengthInBytes() uint16 {
	return m.LengthInBits() / 8
}

func MQTT_ControlPacket_CONNECTParse(readBuffer utils.ReadBuffer) (*MQTT_ControlPacket, error) {
	if pullErr := readBuffer.PullContext("MQTT_ControlPacket_CONNECT"); pullErr != nil {
		return nil, pullErr
	}

	// Reserved Field (Compartmentalized so the "reserved" variable can't leak)
	{
		reserved, _err := readBuffer.ReadUint8("reserved", 4)
		if _err != nil {
			return nil, errors.Wrap(_err, "Error parsing 'reserved' field")
		}
		if reserved != uint8(0x0) {
			log.Info().Fields(map[string]interface{}{
				"expected value": uint8(0x0),
				"got value": reserved,
			}).Msg("Got unexpected response.")
		}
	}

	// Simple Field (remainingLength)
_remainingLength, _remainingLengthErr := readBuffer.ReadUint8("remainingLength", 8)
	if _remainingLengthErr != nil {
		return nil, errors.Wrap(_remainingLengthErr, "Error parsing 'remainingLength' field")
	}
	remainingLength := _remainingLength

	// Simple Field (protocolName)
	if pullErr := readBuffer.PullContext("protocolName"); pullErr != nil {
		return nil, pullErr
	}
_protocolName, _protocolNameErr := MQTT_StringParse(readBuffer)
	if _protocolNameErr != nil {
		return nil, errors.Wrap(_protocolNameErr, "Error parsing 'protocolName' field")
	}
	protocolName := CastMQTT_String(_protocolName)
	if closeErr := readBuffer.CloseContext("protocolName"); closeErr != nil {
		return nil, closeErr
	}

	// Simple Field (protocolVersion)
_protocolVersion, _protocolVersionErr := readBuffer.ReadUint8("protocolVersion", 8)
	if _protocolVersionErr != nil {
		return nil, errors.Wrap(_protocolVersionErr, "Error parsing 'protocolVersion' field")
	}
	protocolVersion := _protocolVersion

	// Simple Field (userNameFlagSet)
_userNameFlagSet, _userNameFlagSetErr := readBuffer.ReadBit("userNameFlagSet")
	if _userNameFlagSetErr != nil {
		return nil, errors.Wrap(_userNameFlagSetErr, "Error parsing 'userNameFlagSet' field")
	}
	userNameFlagSet := _userNameFlagSet

	// Simple Field (passwordFlagSet)
_passwordFlagSet, _passwordFlagSetErr := readBuffer.ReadBit("passwordFlagSet")
	if _passwordFlagSetErr != nil {
		return nil, errors.Wrap(_passwordFlagSetErr, "Error parsing 'passwordFlagSet' field")
	}
	passwordFlagSet := _passwordFlagSet

	// Simple Field (willRetainFlagSet)
_willRetainFlagSet, _willRetainFlagSetErr := readBuffer.ReadBit("willRetainFlagSet")
	if _willRetainFlagSetErr != nil {
		return nil, errors.Wrap(_willRetainFlagSetErr, "Error parsing 'willRetainFlagSet' field")
	}
	willRetainFlagSet := _willRetainFlagSet

	// Simple Field (willQosLevel)
_willQosLevel, _willQosLevelErr := readBuffer.ReadUint8("willQosLevel", 2)
	if _willQosLevelErr != nil {
		return nil, errors.Wrap(_willQosLevelErr, "Error parsing 'willQosLevel' field")
	}
	willQosLevel := _willQosLevel

	// Simple Field (willFlagSet)
_willFlagSet, _willFlagSetErr := readBuffer.ReadBit("willFlagSet")
	if _willFlagSetErr != nil {
		return nil, errors.Wrap(_willFlagSetErr, "Error parsing 'willFlagSet' field")
	}
	willFlagSet := _willFlagSet

	// Simple Field (cleanStartFlagSet)
_cleanStartFlagSet, _cleanStartFlagSetErr := readBuffer.ReadBit("cleanStartFlagSet")
	if _cleanStartFlagSetErr != nil {
		return nil, errors.Wrap(_cleanStartFlagSetErr, "Error parsing 'cleanStartFlagSet' field")
	}
	cleanStartFlagSet := _cleanStartFlagSet

	// Reserved Field (Compartmentalized so the "reserved" variable can't leak)
	{
		reserved, _err := readBuffer.ReadBit("reserved")
		if _err != nil {
			return nil, errors.Wrap(_err, "Error parsing 'reserved' field")
		}
		if reserved != bool(false) {
			log.Info().Fields(map[string]interface{}{
				"expected value": bool(false),
				"got value": reserved,
			}).Msg("Got unexpected response.")
		}
	}

	// Simple Field (keepAlive)
_keepAlive, _keepAliveErr := readBuffer.ReadUint16("keepAlive", 16)
	if _keepAliveErr != nil {
		return nil, errors.Wrap(_keepAliveErr, "Error parsing 'keepAlive' field")
	}
	keepAlive := _keepAlive

	// Simple Field (propertyLength)
_propertyLength, _propertyLengthErr := readBuffer.ReadUint32("propertyLength", 32)
	if _propertyLengthErr != nil {
		return nil, errors.Wrap(_propertyLengthErr, "Error parsing 'propertyLength' field")
	}
	propertyLength := _propertyLength

	// Array field (properties)
	if pullErr := readBuffer.PullContext("properties", utils.WithRenderAsList(true)); pullErr != nil {
		return nil, pullErr
	}
	// Length array
	properties := make([]*MQTT_Property, 0)
	{
		_propertiesLength := propertyLength
		_propertiesEndPos := readBuffer.GetPos() + uint16(_propertiesLength)
		for ;readBuffer.GetPos() < _propertiesEndPos; {
			_item, _err := MQTT_PropertyParse(readBuffer)
			if _err != nil {
				return nil, errors.Wrap(_err, "Error parsing 'properties' field")
			}
			properties = append(properties, _item)
		}
	}
	if closeErr := readBuffer.CloseContext("properties", utils.WithRenderAsList(true)); closeErr != nil {
		return nil, closeErr
	}

	// Simple Field (clientId)
	if pullErr := readBuffer.PullContext("clientId"); pullErr != nil {
		return nil, pullErr
	}
_clientId, _clientIdErr := MQTT_StringParse(readBuffer)
	if _clientIdErr != nil {
		return nil, errors.Wrap(_clientIdErr, "Error parsing 'clientId' field")
	}
	clientId := CastMQTT_String(_clientId)
	if closeErr := readBuffer.CloseContext("clientId"); closeErr != nil {
		return nil, closeErr
	}

	// Optional Field (username) (Can be skipped, if a given expression evaluates to false)
	var username *MQTT_String = nil
	if userNameFlagSet {
		currentPos := readBuffer.GetPos()
		if pullErr := readBuffer.PullContext("username"); pullErr != nil {
			return nil, pullErr
		}
_val, _err := MQTT_StringParse(readBuffer)
		switch {
		case _err != nil && _err != utils.ParseAssertError:
			return nil, errors.Wrap(_err, "Error parsing 'username' field")
		case _err == utils.ParseAssertError:
			readBuffer.SetPos(currentPos)
		default:
			username = CastMQTT_String(_val)
			if closeErr := readBuffer.CloseContext("username"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	// Optional Field (password) (Can be skipped, if a given expression evaluates to false)
	var password *MQTT_String = nil
	if passwordFlagSet {
		currentPos := readBuffer.GetPos()
		if pullErr := readBuffer.PullContext("password"); pullErr != nil {
			return nil, pullErr
		}
_val, _err := MQTT_StringParse(readBuffer)
		switch {
		case _err != nil && _err != utils.ParseAssertError:
			return nil, errors.Wrap(_err, "Error parsing 'password' field")
		case _err == utils.ParseAssertError:
			readBuffer.SetPos(currentPos)
		default:
			password = CastMQTT_String(_val)
			if closeErr := readBuffer.CloseContext("password"); closeErr != nil {
				return nil, closeErr
			}
		}
	}

	if closeErr := readBuffer.CloseContext("MQTT_ControlPacket_CONNECT"); closeErr != nil {
		return nil, closeErr
	}

	// Create a partially initialized instance
	_child := &MQTT_ControlPacket_CONNECT{
		RemainingLength: remainingLength,
		ProtocolName: CastMQTT_String(protocolName),
		ProtocolVersion: protocolVersion,
		UserNameFlagSet: userNameFlagSet,
		PasswordFlagSet: passwordFlagSet,
		WillRetainFlagSet: willRetainFlagSet,
		WillQosLevel: willQosLevel,
		WillFlagSet: willFlagSet,
		CleanStartFlagSet: cleanStartFlagSet,
		KeepAlive: keepAlive,
		PropertyLength: propertyLength,
		Properties: properties,
		ClientId: CastMQTT_String(clientId),
		Username: CastMQTT_String(username),
		Password: CastMQTT_String(password),
        MQTT_ControlPacket: &MQTT_ControlPacket{},
	}
	_child.MQTT_ControlPacket.Child = _child
	return _child.MQTT_ControlPacket, nil
}

func (m *MQTT_ControlPacket_CONNECT) Serialize(writeBuffer utils.WriteBuffer) error {
	ser := func() error {
		if pushErr := writeBuffer.PushContext("MQTT_ControlPacket_CONNECT"); pushErr != nil {
			return pushErr
		}

	// Reserved Field (reserved)
	{
		_err := writeBuffer.WriteUint8("reserved", 4, uint8(0x0))
		if _err != nil {
			return errors.Wrap(_err, "Error serializing 'reserved' field")
		}
	}

	// Simple Field (remainingLength)
	remainingLength := uint8(m.RemainingLength)
	_remainingLengthErr := writeBuffer.WriteUint8("remainingLength", 8, (remainingLength))
	if _remainingLengthErr != nil {
		return errors.Wrap(_remainingLengthErr, "Error serializing 'remainingLength' field")
	}

	// Simple Field (protocolName)
	if pushErr := writeBuffer.PushContext("protocolName"); pushErr != nil {
		return pushErr
	}
	_protocolNameErr := m.ProtocolName.Serialize(writeBuffer)
	if popErr := writeBuffer.PopContext("protocolName"); popErr != nil {
		return popErr
	}
	if _protocolNameErr != nil {
		return errors.Wrap(_protocolNameErr, "Error serializing 'protocolName' field")
	}

	// Simple Field (protocolVersion)
	protocolVersion := uint8(m.ProtocolVersion)
	_protocolVersionErr := writeBuffer.WriteUint8("protocolVersion", 8, (protocolVersion))
	if _protocolVersionErr != nil {
		return errors.Wrap(_protocolVersionErr, "Error serializing 'protocolVersion' field")
	}

	// Simple Field (userNameFlagSet)
	userNameFlagSet := bool(m.UserNameFlagSet)
	_userNameFlagSetErr := writeBuffer.WriteBit("userNameFlagSet", (userNameFlagSet))
	if _userNameFlagSetErr != nil {
		return errors.Wrap(_userNameFlagSetErr, "Error serializing 'userNameFlagSet' field")
	}

	// Simple Field (passwordFlagSet)
	passwordFlagSet := bool(m.PasswordFlagSet)
	_passwordFlagSetErr := writeBuffer.WriteBit("passwordFlagSet", (passwordFlagSet))
	if _passwordFlagSetErr != nil {
		return errors.Wrap(_passwordFlagSetErr, "Error serializing 'passwordFlagSet' field")
	}

	// Simple Field (willRetainFlagSet)
	willRetainFlagSet := bool(m.WillRetainFlagSet)
	_willRetainFlagSetErr := writeBuffer.WriteBit("willRetainFlagSet", (willRetainFlagSet))
	if _willRetainFlagSetErr != nil {
		return errors.Wrap(_willRetainFlagSetErr, "Error serializing 'willRetainFlagSet' field")
	}

	// Simple Field (willQosLevel)
	willQosLevel := uint8(m.WillQosLevel)
	_willQosLevelErr := writeBuffer.WriteUint8("willQosLevel", 2, (willQosLevel))
	if _willQosLevelErr != nil {
		return errors.Wrap(_willQosLevelErr, "Error serializing 'willQosLevel' field")
	}

	// Simple Field (willFlagSet)
	willFlagSet := bool(m.WillFlagSet)
	_willFlagSetErr := writeBuffer.WriteBit("willFlagSet", (willFlagSet))
	if _willFlagSetErr != nil {
		return errors.Wrap(_willFlagSetErr, "Error serializing 'willFlagSet' field")
	}

	// Simple Field (cleanStartFlagSet)
	cleanStartFlagSet := bool(m.CleanStartFlagSet)
	_cleanStartFlagSetErr := writeBuffer.WriteBit("cleanStartFlagSet", (cleanStartFlagSet))
	if _cleanStartFlagSetErr != nil {
		return errors.Wrap(_cleanStartFlagSetErr, "Error serializing 'cleanStartFlagSet' field")
	}

	// Reserved Field (reserved)
	{
		_err := writeBuffer.WriteBit("reserved", bool(false))
		if _err != nil {
			return errors.Wrap(_err, "Error serializing 'reserved' field")
		}
	}

	// Simple Field (keepAlive)
	keepAlive := uint16(m.KeepAlive)
	_keepAliveErr := writeBuffer.WriteUint16("keepAlive", 16, (keepAlive))
	if _keepAliveErr != nil {
		return errors.Wrap(_keepAliveErr, "Error serializing 'keepAlive' field")
	}

	// Simple Field (propertyLength)
	propertyLength := uint32(m.PropertyLength)
	_propertyLengthErr := writeBuffer.WriteUint32("propertyLength", 32, (propertyLength))
	if _propertyLengthErr != nil {
		return errors.Wrap(_propertyLengthErr, "Error serializing 'propertyLength' field")
	}

	// Array Field (properties)
	if m.Properties != nil {
		if pushErr := writeBuffer.PushContext("properties", utils.WithRenderAsList(true)); pushErr != nil {
			return pushErr
		}
		for _, _element := range m.Properties {
			_elementErr := _element.Serialize(writeBuffer)
			if _elementErr != nil {
				return errors.Wrap(_elementErr, "Error serializing 'properties' field")
			}
		}
		if popErr := writeBuffer.PopContext("properties", utils.WithRenderAsList(true)); popErr != nil {
			return popErr
		}
	}

	// Simple Field (clientId)
	if pushErr := writeBuffer.PushContext("clientId"); pushErr != nil {
		return pushErr
	}
	_clientIdErr := m.ClientId.Serialize(writeBuffer)
	if popErr := writeBuffer.PopContext("clientId"); popErr != nil {
		return popErr
	}
	if _clientIdErr != nil {
		return errors.Wrap(_clientIdErr, "Error serializing 'clientId' field")
	}

	// Optional Field (username) (Can be skipped, if the value is null)
	var username *MQTT_String = nil
	if m.Username != nil {
		if pushErr := writeBuffer.PushContext("username"); pushErr != nil {
			return pushErr
		}
		username = m.Username
		_usernameErr := username.Serialize(writeBuffer)
		if popErr := writeBuffer.PopContext("username"); popErr != nil {
			return popErr
		}
		if _usernameErr != nil {
			return errors.Wrap(_usernameErr, "Error serializing 'username' field")
		}
	}

	// Optional Field (password) (Can be skipped, if the value is null)
	var password *MQTT_String = nil
	if m.Password != nil {
		if pushErr := writeBuffer.PushContext("password"); pushErr != nil {
			return pushErr
		}
		password = m.Password
		_passwordErr := password.Serialize(writeBuffer)
		if popErr := writeBuffer.PopContext("password"); popErr != nil {
			return popErr
		}
		if _passwordErr != nil {
			return errors.Wrap(_passwordErr, "Error serializing 'password' field")
		}
	}

		if popErr := writeBuffer.PopContext("MQTT_ControlPacket_CONNECT"); popErr != nil {
			return popErr
		}
		return nil
	}
	return m.SerializeParent(writeBuffer, m, ser)
}

func (m *MQTT_ControlPacket_CONNECT) String() string {
	if m == nil {
		return "<nil>"
	}
	buffer := utils.NewBoxedWriteBufferWithOptions(true, true)
	m.Serialize(buffer)
	return buffer.GetBox().String()
}



