/*
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 */

#include <stdio.h>
#include <plc4c/spi/evaluation_helper.h>
#include "mqt_t__control_packet.h"

// Code generated by code-generation. DO NOT EDIT.

// Array of discriminator values that match the enum type constants.
// (The order is identical to the enum constants so we can use the
// enum constant to directly access a given types discriminator values)
const plc4c_mqtt_read_write_mqt_t__control_packet_discriminator plc4c_mqtt_read_write_mqt_t__control_packet_discriminators[] = {
  {/* plc4c_mqtt_read_write_mqt_t__control_packet__connect */
   .packetType = plc4c_mqtt_read_write_mqt_t__control_packet_type_CONNECT },
  {/* plc4c_mqtt_read_write_mqt_t__control_packet__connack */
   .packetType = plc4c_mqtt_read_write_mqt_t__control_packet_type_CONNACK },
  {/* plc4c_mqtt_read_write_mqt_t__control_packet__publish */
   .packetType = plc4c_mqtt_read_write_mqt_t__control_packet_type_PUBLISH },
  {/* plc4c_mqtt_read_write_mqt_t__control_packet__puback */
   .packetType = plc4c_mqtt_read_write_mqt_t__control_packet_type_PUBACK },
  {/* plc4c_mqtt_read_write_mqt_t__control_packet__pubrec */
   .packetType = plc4c_mqtt_read_write_mqt_t__control_packet_type_PUBREC },
  {/* plc4c_mqtt_read_write_mqt_t__control_packet__pubrel */
   .packetType = plc4c_mqtt_read_write_mqt_t__control_packet_type_PUBREL },
  {/* plc4c_mqtt_read_write_mqt_t__control_packet__pubcomp */
   .packetType = plc4c_mqtt_read_write_mqt_t__control_packet_type_PUBCOMP },
  {/* plc4c_mqtt_read_write_mqt_t__control_packet__subscribe */
   .packetType = plc4c_mqtt_read_write_mqt_t__control_packet_type_SUBSCRIBE },
  {/* plc4c_mqtt_read_write_mqt_t__control_packet__suback */
   .packetType = plc4c_mqtt_read_write_mqt_t__control_packet_type_SUBACK },
  {/* plc4c_mqtt_read_write_mqt_t__control_packet__unsubscribe */
   .packetType = plc4c_mqtt_read_write_mqt_t__control_packet_type_UNSUBSCRIBE },
  {/* plc4c_mqtt_read_write_mqt_t__control_packet__unsuback */
   .packetType = plc4c_mqtt_read_write_mqt_t__control_packet_type_UNSUBACK },
  {/* plc4c_mqtt_read_write_mqt_t__control_packet__pingreq */
   .packetType = plc4c_mqtt_read_write_mqt_t__control_packet_type_PINGREQ },
  {/* plc4c_mqtt_read_write_mqt_t__control_packet__pingresp */
   .packetType = plc4c_mqtt_read_write_mqt_t__control_packet_type_PINGRESP },
  {/* plc4c_mqtt_read_write_mqt_t__control_packet__disconnect */
   .packetType = plc4c_mqtt_read_write_mqt_t__control_packet_type_DISCONNECT },
  {/* plc4c_mqtt_read_write_mqt_t__control_packet__auth */
   .packetType = plc4c_mqtt_read_write_mqt_t__control_packet_type_AUTH }

};

// Function returning the discriminator values for a given type constant.
plc4c_mqtt_read_write_mqt_t__control_packet_discriminator plc4c_mqtt_read_write_mqt_t__control_packet_get_discriminator(plc4c_mqtt_read_write_mqt_t__control_packet_type type) {
  return plc4c_mqtt_read_write_mqt_t__control_packet_discriminators[type];
}

// Create an empty NULL-struct
static const plc4c_mqtt_read_write_mqt_t__control_packet plc4c_mqtt_read_write_mqt_t__control_packet_null_const;

plc4c_mqtt_read_write_mqt_t__control_packet plc4c_mqtt_read_write_mqt_t__control_packet_null() {
  return plc4c_mqtt_read_write_mqt_t__control_packet_null_const;
}


// Parse function.
plc4c_return_code plc4c_mqtt_read_write_mqt_t__control_packet_parse(plc4c_spi_read_buffer* readBuffer, plc4c_mqtt_read_write_mqt_t__control_packet** _message) {
  uint16_t startPos = plc4c_spi_read_get_pos(readBuffer);
  plc4c_return_code _res = OK;

  // Allocate enough memory to contain this data structure.
  (*_message) = malloc(sizeof(plc4c_mqtt_read_write_mqt_t__control_packet));
  if(*_message == NULL) {
    return NO_MEMORY;
  }
        // Discriminator Field (packetType)
  enum plc4c_mqtt_read_write_mqt_t__control_packet_type packetType;
  _res = plc4c_spi_read_unsigned_byte(readBuffer, 4, (uint8_t*) &packetType);
  if(_res != OK) {
    return _res;
  }

  // Switch Field (Depending on the discriminator values, passes the instantiation to a sub-type)
  if(packetType == plc4c_mqtt_read_write_mqt_t__control_packet_type_CONNECT) { /* MQTT_ControlPacket_CONNECT */
    (*_message)->_type = plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__connect;
                    
    // Reserved Field (Compartmentalized so the "reserved" variable can't leak)
    {
      uint8_t _reserved = 0;
      _res = plc4c_spi_read_unsigned_byte(readBuffer, 4, (uint8_t*) &_reserved);
      if(_res != OK) {
        return _res;
      }
      if(_reserved != 0x0) {
        printf("Expected constant value '%d' but got '%d' for reserved field.", 0x0, _reserved);
      }
    }


                    
    // Simple Field (remainingLength)
    uint8_t remainingLength = 0;
    _res = plc4c_spi_read_unsigned_byte(readBuffer, 8, (uint8_t*) &remainingLength);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__connect_remaining_length = remainingLength;


                    
    // Simple Field (protocolName)
    plc4c_mqtt_read_write_mqt_t__string* protocolName;
    _res = plc4c_mqtt_read_write_mqt_t__string_parse(readBuffer, (void*) &protocolName);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__connect_protocol_name = protocolName;


                    
    // Simple Field (protocolVersion)
    uint8_t protocolVersion = 0;
    _res = plc4c_spi_read_unsigned_byte(readBuffer, 8, (uint8_t*) &protocolVersion);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__connect_protocol_version = protocolVersion;


                    
    // Simple Field (userNameFlagSet)
    bool userNameFlagSet = false;
    _res = plc4c_spi_read_bit(readBuffer, (bool*) &userNameFlagSet);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__connect_user_name_flag_set = userNameFlagSet;


                    
    // Simple Field (passwordFlagSet)
    bool passwordFlagSet = false;
    _res = plc4c_spi_read_bit(readBuffer, (bool*) &passwordFlagSet);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__connect_password_flag_set = passwordFlagSet;


                    
    // Simple Field (willRetainFlagSet)
    bool willRetainFlagSet = false;
    _res = plc4c_spi_read_bit(readBuffer, (bool*) &willRetainFlagSet);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__connect_will_retain_flag_set = willRetainFlagSet;


                    
    // Simple Field (willQosLevel)
    uint8_t willQosLevel = 0;
    _res = plc4c_spi_read_unsigned_byte(readBuffer, 2, (uint8_t*) &willQosLevel);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__connect_will_qos_level = willQosLevel;


                    
    // Simple Field (willFlagSet)
    bool willFlagSet = false;
    _res = plc4c_spi_read_bit(readBuffer, (bool*) &willFlagSet);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__connect_will_flag_set = willFlagSet;


                    
    // Simple Field (cleanStartFlagSet)
    bool cleanStartFlagSet = false;
    _res = plc4c_spi_read_bit(readBuffer, (bool*) &cleanStartFlagSet);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__connect_clean_start_flag_set = cleanStartFlagSet;


                    
    // Reserved Field (Compartmentalized so the "reserved" variable can't leak)
    {
      bool _reserved = false;
      _res = plc4c_spi_read_bit(readBuffer, (bool*) &_reserved);
      if(_res != OK) {
        return _res;
      }
      if(_reserved != false) {
        printf("Expected constant value '%d' but got '%d' for reserved field.", false, _reserved);
      }
    }


                    
    // Simple Field (keepAlive)
    uint16_t keepAlive = 0;
    _res = plc4c_spi_read_unsigned_short(readBuffer, 16, (uint16_t*) &keepAlive);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__connect_keep_alive = keepAlive;


                    
    // Simple Field (propertyLength)
    uint32_t propertyLength = 0;
    _res = plc4c_spi_read_unsigned_int(readBuffer, 32, (uint32_t*) &propertyLength);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__connect_property_length = propertyLength;


                    
    // Array field (properties)
    plc4c_list* properties = NULL;
    plc4c_utils_list_create(&properties);
    if(properties == NULL) {
      return NO_MEMORY;
    }
    {
      // Length array
      uint8_t _propertiesLength = propertyLength;
      uint8_t propertiesEndPos = plc4c_spi_read_get_pos(readBuffer) + _propertiesLength;
      while(plc4c_spi_read_get_pos(readBuffer) < propertiesEndPos) {
        plc4c_mqtt_read_write_mqt_t__property* _value = NULL;
        _res = plc4c_mqtt_read_write_mqt_t__property_parse(readBuffer, (void*) &_value);
        if(_res != OK) {
          return _res;
        }
        plc4c_utils_list_insert_head_value(properties, _value);
      }
    }
    (*_message)->mqt_t__control_packet__connect_properties = properties;


                    
    // Simple Field (clientId)
    plc4c_mqtt_read_write_mqt_t__string* clientId;
    _res = plc4c_mqtt_read_write_mqt_t__string_parse(readBuffer, (void*) &clientId);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__connect_client_id = clientId;


                    
    // Optional Field (username) (Can be skipped, if a given expression evaluates to false)
    plc4c_mqtt_read_write_mqt_t__string* username = NULL;
    if(userNameFlagSet) {
      _res = plc4c_mqtt_read_write_mqt_t__string_parse(readBuffer, &username);
      if(_res != OK) {
        return _res;
      }
      (*_message)->mqt_t__control_packet__connect_username = username;
    } else {
      (*_message)->mqt_t__control_packet__connect_username = NULL;
    }


                    
    // Optional Field (password) (Can be skipped, if a given expression evaluates to false)
    plc4c_mqtt_read_write_mqt_t__string* password = NULL;
    if(passwordFlagSet) {
      _res = plc4c_mqtt_read_write_mqt_t__string_parse(readBuffer, &password);
      if(_res != OK) {
        return _res;
      }
      (*_message)->mqt_t__control_packet__connect_password = password;
    } else {
      (*_message)->mqt_t__control_packet__connect_password = NULL;
    }

  } else 
  if(packetType == plc4c_mqtt_read_write_mqt_t__control_packet_type_CONNACK) { /* MQTT_ControlPacket_CONNACK */
    (*_message)->_type = plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__connack;
                    
    // Reserved Field (Compartmentalized so the "reserved" variable can't leak)
    {
      uint8_t _reserved = 0;
      _res = plc4c_spi_read_unsigned_byte(readBuffer, 4, (uint8_t*) &_reserved);
      if(_res != OK) {
        return _res;
      }
      if(_reserved != 0x0) {
        printf("Expected constant value '%d' but got '%d' for reserved field.", 0x0, _reserved);
      }
    }


                    
    // Simple Field (remainingLength)
    uint8_t remainingLength = 0;
    _res = plc4c_spi_read_unsigned_byte(readBuffer, 8, (uint8_t*) &remainingLength);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__connack_remaining_length = remainingLength;


                    
    // Reserved Field (Compartmentalized so the "reserved" variable can't leak)
    {
      uint8_t _reserved = 0;
      _res = plc4c_spi_read_unsigned_byte(readBuffer, 7, (uint8_t*) &_reserved);
      if(_res != OK) {
        return _res;
      }
      if(_reserved != 0x00) {
        printf("Expected constant value '%d' but got '%d' for reserved field.", 0x00, _reserved);
      }
    }


                    
    // Simple Field (sessionPresentFlagSet)
    bool sessionPresentFlagSet = false;
    _res = plc4c_spi_read_bit(readBuffer, (bool*) &sessionPresentFlagSet);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__connack_session_present_flag_set = sessionPresentFlagSet;


                    
    // Simple Field (reasonCode)
    plc4c_mqtt_read_write_mqt_t__reason_code* reasonCode;
    _res = plc4c_mqtt_read_write_mqt_t__reason_code_parse(readBuffer, (void*) &reasonCode);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__connack_reason_code = *reasonCode;


                    
    // Optional Field (propertyLength) (Can be skipped, if a given expression evaluates to false)
    uint32_t* propertyLength = NULL;
    if(((remainingLength) - ((plc4c_spi_read_get_pos(readBuffer) - startPos))) < (4)) {
      propertyLength = malloc(sizeof(uint32_t));
      if(propertyLength == NULL) {
        return NO_MEMORY;
      }
      *propertyLength = 0;
      _res = plc4c_spi_read_unsigned_int(readBuffer, 32, (uint32_t*) propertyLength);
      if(_res != OK) {
        return _res;
      }
      (*_message)->mqt_t__control_packet__connack_property_length = propertyLength;
    } else {
      (*_message)->mqt_t__control_packet__connack_property_length = NULL;
    }


                    
    // Array field (properties)
    plc4c_list* properties = NULL;
    plc4c_utils_list_create(&properties);
    if(properties == NULL) {
      return NO_MEMORY;
    }
    {
      // Length array
      uint8_t _propertiesLength = ((((propertyLength) != (NULL))) ? propertyLength : 0);
      uint8_t propertiesEndPos = plc4c_spi_read_get_pos(readBuffer) + _propertiesLength;
      while(plc4c_spi_read_get_pos(readBuffer) < propertiesEndPos) {
        plc4c_mqtt_read_write_mqt_t__property* _value = NULL;
        _res = plc4c_mqtt_read_write_mqt_t__property_parse(readBuffer, (void*) &_value);
        if(_res != OK) {
          return _res;
        }
        plc4c_utils_list_insert_head_value(properties, _value);
      }
    }
    (*_message)->mqt_t__control_packet__connack_properties = properties;

  } else 
  if(packetType == plc4c_mqtt_read_write_mqt_t__control_packet_type_PUBLISH) { /* MQTT_ControlPacket_PUBLISH */
    (*_message)->_type = plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__publish;
                    
    // Simple Field (dup)
    bool dup = false;
    _res = plc4c_spi_read_bit(readBuffer, (bool*) &dup);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__publish_dup = dup;


                    
    // Simple Field (qos)
    plc4c_mqtt_read_write_mqt_t__qos* qos;
    _res = plc4c_mqtt_read_write_mqt_t__qos_parse(readBuffer, (void*) &qos);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__publish_qos = *qos;


                    
    // Simple Field (retain)
    bool retain = false;
    _res = plc4c_spi_read_bit(readBuffer, (bool*) &retain);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__publish_retain = retain;


                    
    // Simple Field (remainingLength)
    uint8_t remainingLength = 0;
    _res = plc4c_spi_read_unsigned_byte(readBuffer, 8, (uint8_t*) &remainingLength);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__publish_remaining_length = remainingLength;


                    
    // Simple Field (topicName)
    plc4c_mqtt_read_write_mqt_t__string* topicName;
    _res = plc4c_mqtt_read_write_mqt_t__string_parse(readBuffer, (void*) &topicName);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__publish_topic_name = topicName;


                    
    // Optional Field (packetIdentifier) (Can be skipped, if a given expression evaluates to false)
    uint16_t* packetIdentifier = NULL;
    if((qos) != (plc4c_mqtt_read_write_mqt_t__qos_AT_MOST_ONCE)) {
      packetIdentifier = malloc(sizeof(uint16_t));
      if(packetIdentifier == NULL) {
        return NO_MEMORY;
      }
      *packetIdentifier = 0;
      _res = plc4c_spi_read_unsigned_short(readBuffer, 16, (uint16_t*) packetIdentifier);
      if(_res != OK) {
        return _res;
      }
      (*_message)->mqt_t__control_packet__publish_packet_identifier = packetIdentifier;
    } else {
      (*_message)->mqt_t__control_packet__publish_packet_identifier = NULL;
    }


                    
    // Optional Field (propertyLength) (Can be skipped, if a given expression evaluates to false)
    uint32_t* propertyLength = NULL;
    if(((remainingLength) - ((plc4c_spi_read_get_pos(readBuffer) - startPos))) < (4)) {
      propertyLength = malloc(sizeof(uint32_t));
      if(propertyLength == NULL) {
        return NO_MEMORY;
      }
      *propertyLength = 0;
      _res = plc4c_spi_read_unsigned_int(readBuffer, 32, (uint32_t*) propertyLength);
      if(_res != OK) {
        return _res;
      }
      (*_message)->mqt_t__control_packet__publish_property_length = propertyLength;
    } else {
      (*_message)->mqt_t__control_packet__publish_property_length = NULL;
    }


                    
    // Array field (properties)
    plc4c_list* properties = NULL;
    plc4c_utils_list_create(&properties);
    if(properties == NULL) {
      return NO_MEMORY;
    }
    {
      // Length array
      uint8_t _propertiesLength = ((((propertyLength) != (NULL))) ? propertyLength : 0);
      uint8_t propertiesEndPos = plc4c_spi_read_get_pos(readBuffer) + _propertiesLength;
      while(plc4c_spi_read_get_pos(readBuffer) < propertiesEndPos) {
        plc4c_mqtt_read_write_mqt_t__property* _value = NULL;
        _res = plc4c_mqtt_read_write_mqt_t__property_parse(readBuffer, (void*) &_value);
        if(_res != OK) {
          return _res;
        }
        plc4c_utils_list_insert_head_value(properties, _value);
      }
    }
    (*_message)->mqt_t__control_packet__publish_properties = properties;


                    
    // Array field (payload)
    plc4c_list* payload = NULL;
    plc4c_utils_list_create(&payload);
    if(payload == NULL) {
      return NO_MEMORY;
    }
    {
      // Count array
      uint16_t itemCount = (uint16_t) (remainingLength) - ((plc4c_spi_read_get_pos(readBuffer) - startPos));
      for(int curItem = 0; curItem < itemCount; curItem++) {
        
        char* _value = malloc(sizeof(char));
        _res = plc4c_spi_read_char(readBuffer, (char*) _value);
        if(_res != OK) {
          return _res;
        }
        plc4c_utils_list_insert_head_value(payload, _value);
      }
    }
    (*_message)->mqt_t__control_packet__publish_payload = payload;

  } else 
  if(packetType == plc4c_mqtt_read_write_mqt_t__control_packet_type_PUBACK) { /* MQTT_ControlPacket_PUBACK */
    (*_message)->_type = plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__puback;
                    
    // Reserved Field (Compartmentalized so the "reserved" variable can't leak)
    {
      uint8_t _reserved = 0;
      _res = plc4c_spi_read_unsigned_byte(readBuffer, 4, (uint8_t*) &_reserved);
      if(_res != OK) {
        return _res;
      }
      if(_reserved != 0x0) {
        printf("Expected constant value '%d' but got '%d' for reserved field.", 0x0, _reserved);
      }
    }


                    
    // Simple Field (remainingLength)
    uint8_t remainingLength = 0;
    _res = plc4c_spi_read_unsigned_byte(readBuffer, 8, (uint8_t*) &remainingLength);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__puback_remaining_length = remainingLength;


                    
    // Simple Field (packetIdentifier)
    uint16_t packetIdentifier = 0;
    _res = plc4c_spi_read_unsigned_short(readBuffer, 16, (uint16_t*) &packetIdentifier);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__puback_packet_identifier = packetIdentifier;


                    
    // Optional Field (reasonCode) (Can be skipped, if a given expression evaluates to false)
    plc4c_mqtt_read_write_mqt_t__reason_code* reasonCode = NULL;
    if(((remainingLength) - ((plc4c_spi_read_get_pos(readBuffer) - startPos))) < (3)) {
      _res = plc4c_mqtt_read_write_mqt_t__reason_code_parse(readBuffer, &reasonCode);
      if(_res != OK) {
        return _res;
      }
      (*_message)->mqt_t__control_packet__puback_reason_code = reasonCode;
    } else {
      (*_message)->mqt_t__control_packet__puback_reason_code = NULL;
    }


                    
    // Optional Field (propertyLength) (Can be skipped, if a given expression evaluates to false)
    uint32_t* propertyLength = NULL;
    if(((remainingLength) - ((plc4c_spi_read_get_pos(readBuffer) - startPos))) < (4)) {
      propertyLength = malloc(sizeof(uint32_t));
      if(propertyLength == NULL) {
        return NO_MEMORY;
      }
      *propertyLength = 0;
      _res = plc4c_spi_read_unsigned_int(readBuffer, 32, (uint32_t*) propertyLength);
      if(_res != OK) {
        return _res;
      }
      (*_message)->mqt_t__control_packet__puback_property_length = propertyLength;
    } else {
      (*_message)->mqt_t__control_packet__puback_property_length = NULL;
    }


                    
    // Array field (properties)
    plc4c_list* properties = NULL;
    plc4c_utils_list_create(&properties);
    if(properties == NULL) {
      return NO_MEMORY;
    }
    {
      // Length array
      uint8_t _propertiesLength = ((((propertyLength) != (NULL))) ? propertyLength : 0);
      uint8_t propertiesEndPos = plc4c_spi_read_get_pos(readBuffer) + _propertiesLength;
      while(plc4c_spi_read_get_pos(readBuffer) < propertiesEndPos) {
        plc4c_mqtt_read_write_mqt_t__property* _value = NULL;
        _res = plc4c_mqtt_read_write_mqt_t__property_parse(readBuffer, (void*) &_value);
        if(_res != OK) {
          return _res;
        }
        plc4c_utils_list_insert_head_value(properties, _value);
      }
    }
    (*_message)->mqt_t__control_packet__puback_properties = properties;

  } else 
  if(packetType == plc4c_mqtt_read_write_mqt_t__control_packet_type_PUBREC) { /* MQTT_ControlPacket_PUBREC */
    (*_message)->_type = plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__pubrec;
                    
    // Reserved Field (Compartmentalized so the "reserved" variable can't leak)
    {
      uint8_t _reserved = 0;
      _res = plc4c_spi_read_unsigned_byte(readBuffer, 4, (uint8_t*) &_reserved);
      if(_res != OK) {
        return _res;
      }
      if(_reserved != 0x0) {
        printf("Expected constant value '%d' but got '%d' for reserved field.", 0x0, _reserved);
      }
    }


                    
    // Simple Field (remainingLength)
    uint8_t remainingLength = 0;
    _res = plc4c_spi_read_unsigned_byte(readBuffer, 8, (uint8_t*) &remainingLength);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__pubrec_remaining_length = remainingLength;


                    
    // Simple Field (packetIdentifier)
    uint16_t packetIdentifier = 0;
    _res = plc4c_spi_read_unsigned_short(readBuffer, 16, (uint16_t*) &packetIdentifier);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__pubrec_packet_identifier = packetIdentifier;


                    
    // Optional Field (reasonCode) (Can be skipped, if a given expression evaluates to false)
    plc4c_mqtt_read_write_mqt_t__reason_code* reasonCode = NULL;
    if(((remainingLength) - ((plc4c_spi_read_get_pos(readBuffer) - startPos))) < (3)) {
      _res = plc4c_mqtt_read_write_mqt_t__reason_code_parse(readBuffer, &reasonCode);
      if(_res != OK) {
        return _res;
      }
      (*_message)->mqt_t__control_packet__pubrec_reason_code = reasonCode;
    } else {
      (*_message)->mqt_t__control_packet__pubrec_reason_code = NULL;
    }


                    
    // Optional Field (propertyLength) (Can be skipped, if a given expression evaluates to false)
    uint32_t* propertyLength = NULL;
    if(((remainingLength) - ((plc4c_spi_read_get_pos(readBuffer) - startPos))) < (4)) {
      propertyLength = malloc(sizeof(uint32_t));
      if(propertyLength == NULL) {
        return NO_MEMORY;
      }
      *propertyLength = 0;
      _res = plc4c_spi_read_unsigned_int(readBuffer, 32, (uint32_t*) propertyLength);
      if(_res != OK) {
        return _res;
      }
      (*_message)->mqt_t__control_packet__pubrec_property_length = propertyLength;
    } else {
      (*_message)->mqt_t__control_packet__pubrec_property_length = NULL;
    }


                    
    // Array field (properties)
    plc4c_list* properties = NULL;
    plc4c_utils_list_create(&properties);
    if(properties == NULL) {
      return NO_MEMORY;
    }
    {
      // Length array
      uint8_t _propertiesLength = ((((propertyLength) != (NULL))) ? propertyLength : 0);
      uint8_t propertiesEndPos = plc4c_spi_read_get_pos(readBuffer) + _propertiesLength;
      while(plc4c_spi_read_get_pos(readBuffer) < propertiesEndPos) {
        plc4c_mqtt_read_write_mqt_t__property* _value = NULL;
        _res = plc4c_mqtt_read_write_mqt_t__property_parse(readBuffer, (void*) &_value);
        if(_res != OK) {
          return _res;
        }
        plc4c_utils_list_insert_head_value(properties, _value);
      }
    }
    (*_message)->mqt_t__control_packet__pubrec_properties = properties;

  } else 
  if(packetType == plc4c_mqtt_read_write_mqt_t__control_packet_type_PUBREL) { /* MQTT_ControlPacket_PUBREL */
    (*_message)->_type = plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__pubrel;
                    
    // Reserved Field (Compartmentalized so the "reserved" variable can't leak)
    {
      uint8_t _reserved = 0;
      _res = plc4c_spi_read_unsigned_byte(readBuffer, 4, (uint8_t*) &_reserved);
      if(_res != OK) {
        return _res;
      }
      if(_reserved != 0x0) {
        printf("Expected constant value '%d' but got '%d' for reserved field.", 0x0, _reserved);
      }
    }


                    
    // Simple Field (remainingLength)
    uint8_t remainingLength = 0;
    _res = plc4c_spi_read_unsigned_byte(readBuffer, 8, (uint8_t*) &remainingLength);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__pubrel_remaining_length = remainingLength;


                    
    // Simple Field (packetIdentifier)
    uint16_t packetIdentifier = 0;
    _res = plc4c_spi_read_unsigned_short(readBuffer, 16, (uint16_t*) &packetIdentifier);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__pubrel_packet_identifier = packetIdentifier;


                    
    // Optional Field (reasonCode) (Can be skipped, if a given expression evaluates to false)
    plc4c_mqtt_read_write_mqt_t__reason_code* reasonCode = NULL;
    if(((remainingLength) - ((plc4c_spi_read_get_pos(readBuffer) - startPos))) < (3)) {
      _res = plc4c_mqtt_read_write_mqt_t__reason_code_parse(readBuffer, &reasonCode);
      if(_res != OK) {
        return _res;
      }
      (*_message)->mqt_t__control_packet__pubrel_reason_code = reasonCode;
    } else {
      (*_message)->mqt_t__control_packet__pubrel_reason_code = NULL;
    }


                    
    // Optional Field (propertyLength) (Can be skipped, if a given expression evaluates to false)
    uint32_t* propertyLength = NULL;
    if(((remainingLength) - ((plc4c_spi_read_get_pos(readBuffer) - startPos))) < (4)) {
      propertyLength = malloc(sizeof(uint32_t));
      if(propertyLength == NULL) {
        return NO_MEMORY;
      }
      *propertyLength = 0;
      _res = plc4c_spi_read_unsigned_int(readBuffer, 32, (uint32_t*) propertyLength);
      if(_res != OK) {
        return _res;
      }
      (*_message)->mqt_t__control_packet__pubrel_property_length = propertyLength;
    } else {
      (*_message)->mqt_t__control_packet__pubrel_property_length = NULL;
    }


                    
    // Array field (properties)
    plc4c_list* properties = NULL;
    plc4c_utils_list_create(&properties);
    if(properties == NULL) {
      return NO_MEMORY;
    }
    {
      // Length array
      uint8_t _propertiesLength = ((((propertyLength) != (NULL))) ? propertyLength : 0);
      uint8_t propertiesEndPos = plc4c_spi_read_get_pos(readBuffer) + _propertiesLength;
      while(plc4c_spi_read_get_pos(readBuffer) < propertiesEndPos) {
        plc4c_mqtt_read_write_mqt_t__property* _value = NULL;
        _res = plc4c_mqtt_read_write_mqt_t__property_parse(readBuffer, (void*) &_value);
        if(_res != OK) {
          return _res;
        }
        plc4c_utils_list_insert_head_value(properties, _value);
      }
    }
    (*_message)->mqt_t__control_packet__pubrel_properties = properties;

  } else 
  if(packetType == plc4c_mqtt_read_write_mqt_t__control_packet_type_PUBCOMP) { /* MQTT_ControlPacket_PUBCOMP */
    (*_message)->_type = plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__pubcomp;
                    
    // Reserved Field (Compartmentalized so the "reserved" variable can't leak)
    {
      uint8_t _reserved = 0;
      _res = plc4c_spi_read_unsigned_byte(readBuffer, 4, (uint8_t*) &_reserved);
      if(_res != OK) {
        return _res;
      }
      if(_reserved != 0x0) {
        printf("Expected constant value '%d' but got '%d' for reserved field.", 0x0, _reserved);
      }
    }


                    
    // Simple Field (remainingLength)
    uint8_t remainingLength = 0;
    _res = plc4c_spi_read_unsigned_byte(readBuffer, 8, (uint8_t*) &remainingLength);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__pubcomp_remaining_length = remainingLength;


                    
    // Simple Field (packetIdentifier)
    uint16_t packetIdentifier = 0;
    _res = plc4c_spi_read_unsigned_short(readBuffer, 16, (uint16_t*) &packetIdentifier);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__pubcomp_packet_identifier = packetIdentifier;


                    
    // Optional Field (reasonCode) (Can be skipped, if a given expression evaluates to false)
    plc4c_mqtt_read_write_mqt_t__reason_code* reasonCode = NULL;
    if(((remainingLength) - ((plc4c_spi_read_get_pos(readBuffer) - startPos))) < (3)) {
      _res = plc4c_mqtt_read_write_mqt_t__reason_code_parse(readBuffer, &reasonCode);
      if(_res != OK) {
        return _res;
      }
      (*_message)->mqt_t__control_packet__pubcomp_reason_code = reasonCode;
    } else {
      (*_message)->mqt_t__control_packet__pubcomp_reason_code = NULL;
    }


                    
    // Optional Field (propertyLength) (Can be skipped, if a given expression evaluates to false)
    uint32_t* propertyLength = NULL;
    if(((remainingLength) - ((plc4c_spi_read_get_pos(readBuffer) - startPos))) < (4)) {
      propertyLength = malloc(sizeof(uint32_t));
      if(propertyLength == NULL) {
        return NO_MEMORY;
      }
      *propertyLength = 0;
      _res = plc4c_spi_read_unsigned_int(readBuffer, 32, (uint32_t*) propertyLength);
      if(_res != OK) {
        return _res;
      }
      (*_message)->mqt_t__control_packet__pubcomp_property_length = propertyLength;
    } else {
      (*_message)->mqt_t__control_packet__pubcomp_property_length = NULL;
    }


                    
    // Array field (properties)
    plc4c_list* properties = NULL;
    plc4c_utils_list_create(&properties);
    if(properties == NULL) {
      return NO_MEMORY;
    }
    {
      // Length array
      uint8_t _propertiesLength = ((((propertyLength) != (NULL))) ? propertyLength : 0);
      uint8_t propertiesEndPos = plc4c_spi_read_get_pos(readBuffer) + _propertiesLength;
      while(plc4c_spi_read_get_pos(readBuffer) < propertiesEndPos) {
        plc4c_mqtt_read_write_mqt_t__property* _value = NULL;
        _res = plc4c_mqtt_read_write_mqt_t__property_parse(readBuffer, (void*) &_value);
        if(_res != OK) {
          return _res;
        }
        plc4c_utils_list_insert_head_value(properties, _value);
      }
    }
    (*_message)->mqt_t__control_packet__pubcomp_properties = properties;

  } else 
  if(packetType == plc4c_mqtt_read_write_mqt_t__control_packet_type_SUBSCRIBE) { /* MQTT_ControlPacket_SUBSCRIBE */
    (*_message)->_type = plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__subscribe;
                    
    // Reserved Field (Compartmentalized so the "reserved" variable can't leak)
    {
      uint8_t _reserved = 0;
      _res = plc4c_spi_read_unsigned_byte(readBuffer, 4, (uint8_t*) &_reserved);
      if(_res != OK) {
        return _res;
      }
      if(_reserved != 0x0) {
        printf("Expected constant value '%d' but got '%d' for reserved field.", 0x0, _reserved);
      }
    }


                    
    // Simple Field (remainingLength)
    uint8_t remainingLength = 0;
    _res = plc4c_spi_read_unsigned_byte(readBuffer, 8, (uint8_t*) &remainingLength);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__subscribe_remaining_length = remainingLength;


                    
    // Simple Field (packetIdentifier)
    uint16_t packetIdentifier = 0;
    _res = plc4c_spi_read_unsigned_short(readBuffer, 16, (uint16_t*) &packetIdentifier);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__subscribe_packet_identifier = packetIdentifier;


                    
    // Optional Field (propertyLength) (Can be skipped, if a given expression evaluates to false)
    uint32_t* propertyLength = NULL;
    if(((remainingLength) - ((plc4c_spi_read_get_pos(readBuffer) - startPos))) < (4)) {
      propertyLength = malloc(sizeof(uint32_t));
      if(propertyLength == NULL) {
        return NO_MEMORY;
      }
      *propertyLength = 0;
      _res = plc4c_spi_read_unsigned_int(readBuffer, 32, (uint32_t*) propertyLength);
      if(_res != OK) {
        return _res;
      }
      (*_message)->mqt_t__control_packet__subscribe_property_length = propertyLength;
    } else {
      (*_message)->mqt_t__control_packet__subscribe_property_length = NULL;
    }


                    
    // Array field (properties)
    plc4c_list* properties = NULL;
    plc4c_utils_list_create(&properties);
    if(properties == NULL) {
      return NO_MEMORY;
    }
    {
      // Length array
      uint8_t _propertiesLength = ((((propertyLength) != (NULL))) ? propertyLength : 0);
      uint8_t propertiesEndPos = plc4c_spi_read_get_pos(readBuffer) + _propertiesLength;
      while(plc4c_spi_read_get_pos(readBuffer) < propertiesEndPos) {
        plc4c_mqtt_read_write_mqt_t__property* _value = NULL;
        _res = plc4c_mqtt_read_write_mqt_t__property_parse(readBuffer, (void*) &_value);
        if(_res != OK) {
          return _res;
        }
        plc4c_utils_list_insert_head_value(properties, _value);
      }
    }
    (*_message)->mqt_t__control_packet__subscribe_properties = properties;


                    
    // Array field (filters)
    plc4c_list* filters = NULL;
    plc4c_utils_list_create(&filters);
    if(filters == NULL) {
      return NO_MEMORY;
    }
    {
      // Count array
      uint16_t itemCount = (uint16_t) (remainingLength) - ((plc4c_spi_read_get_pos(readBuffer) - startPos));
      for(int curItem = 0; curItem < itemCount; curItem++) {
        bool lastItem = curItem == (itemCount - 1);
        plc4c_mqtt_read_write_filter* _value = NULL;
        _res = plc4c_mqtt_read_write_filter_parse(readBuffer, (void*) &_value);
        if(_res != OK) {
          return _res;
        }
        plc4c_utils_list_insert_head_value(filters, _value);
      }
    }
    (*_message)->mqt_t__control_packet__subscribe_filters = filters;

  } else 
  if(packetType == plc4c_mqtt_read_write_mqt_t__control_packet_type_SUBACK) { /* MQTT_ControlPacket_SUBACK */
    (*_message)->_type = plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__suback;
                    
    // Reserved Field (Compartmentalized so the "reserved" variable can't leak)
    {
      uint8_t _reserved = 0;
      _res = plc4c_spi_read_unsigned_byte(readBuffer, 4, (uint8_t*) &_reserved);
      if(_res != OK) {
        return _res;
      }
      if(_reserved != 0x0) {
        printf("Expected constant value '%d' but got '%d' for reserved field.", 0x0, _reserved);
      }
    }


                    
    // Simple Field (remainingLength)
    uint8_t remainingLength = 0;
    _res = plc4c_spi_read_unsigned_byte(readBuffer, 8, (uint8_t*) &remainingLength);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__suback_remaining_length = remainingLength;


                    
    // Simple Field (packetIdentifier)
    uint16_t packetIdentifier = 0;
    _res = plc4c_spi_read_unsigned_short(readBuffer, 16, (uint16_t*) &packetIdentifier);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__suback_packet_identifier = packetIdentifier;


                    
    // Optional Field (propertyLength) (Can be skipped, if a given expression evaluates to false)
    uint32_t* propertyLength = NULL;
    if(((remainingLength) - ((plc4c_spi_read_get_pos(readBuffer) - startPos))) < (4)) {
      propertyLength = malloc(sizeof(uint32_t));
      if(propertyLength == NULL) {
        return NO_MEMORY;
      }
      *propertyLength = 0;
      _res = plc4c_spi_read_unsigned_int(readBuffer, 32, (uint32_t*) propertyLength);
      if(_res != OK) {
        return _res;
      }
      (*_message)->mqt_t__control_packet__suback_property_length = propertyLength;
    } else {
      (*_message)->mqt_t__control_packet__suback_property_length = NULL;
    }


                    
    // Array field (properties)
    plc4c_list* properties = NULL;
    plc4c_utils_list_create(&properties);
    if(properties == NULL) {
      return NO_MEMORY;
    }
    {
      // Length array
      uint8_t _propertiesLength = ((((propertyLength) != (NULL))) ? propertyLength : 0);
      uint8_t propertiesEndPos = plc4c_spi_read_get_pos(readBuffer) + _propertiesLength;
      while(plc4c_spi_read_get_pos(readBuffer) < propertiesEndPos) {
        plc4c_mqtt_read_write_mqt_t__property* _value = NULL;
        _res = plc4c_mqtt_read_write_mqt_t__property_parse(readBuffer, (void*) &_value);
        if(_res != OK) {
          return _res;
        }
        plc4c_utils_list_insert_head_value(properties, _value);
      }
    }
    (*_message)->mqt_t__control_packet__suback_properties = properties;


                    
    // Array field (results)
    plc4c_list* results = NULL;
    plc4c_utils_list_create(&results);
    if(results == NULL) {
      return NO_MEMORY;
    }
    {
      // Count array
      uint16_t itemCount = (uint16_t) (remainingLength) - ((plc4c_spi_read_get_pos(readBuffer) - startPos));
      for(int curItem = 0; curItem < itemCount; curItem++) {
        bool lastItem = curItem == (itemCount - 1);
        plc4c_mqtt_read_write_mqt_t__reason_code* _value = NULL;
        _res = plc4c_mqtt_read_write_mqt_t__reason_code_parse(readBuffer, (void*) &_value);
        if(_res != OK) {
          return _res;
        }
        plc4c_utils_list_insert_head_value(results, _value);
      }
    }
    (*_message)->mqt_t__control_packet__suback_results = results;

  } else 
  if(packetType == plc4c_mqtt_read_write_mqt_t__control_packet_type_UNSUBSCRIBE) { /* MQTT_ControlPacket_UNSUBSCRIBE */
    (*_message)->_type = plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__unsubscribe;
                    
    // Reserved Field (Compartmentalized so the "reserved" variable can't leak)
    {
      uint8_t _reserved = 0;
      _res = plc4c_spi_read_unsigned_byte(readBuffer, 4, (uint8_t*) &_reserved);
      if(_res != OK) {
        return _res;
      }
      if(_reserved != 0x0) {
        printf("Expected constant value '%d' but got '%d' for reserved field.", 0x0, _reserved);
      }
    }


                    
    // Simple Field (remainingLength)
    uint8_t remainingLength = 0;
    _res = plc4c_spi_read_unsigned_byte(readBuffer, 8, (uint8_t*) &remainingLength);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__unsubscribe_remaining_length = remainingLength;


                    
    // Simple Field (packetIdentifier)
    uint16_t packetIdentifier = 0;
    _res = plc4c_spi_read_unsigned_short(readBuffer, 16, (uint16_t*) &packetIdentifier);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__unsubscribe_packet_identifier = packetIdentifier;


                    
    // Optional Field (propertyLength) (Can be skipped, if a given expression evaluates to false)
    uint32_t* propertyLength = NULL;
    if(((remainingLength) - ((plc4c_spi_read_get_pos(readBuffer) - startPos))) < (4)) {
      propertyLength = malloc(sizeof(uint32_t));
      if(propertyLength == NULL) {
        return NO_MEMORY;
      }
      *propertyLength = 0;
      _res = plc4c_spi_read_unsigned_int(readBuffer, 32, (uint32_t*) propertyLength);
      if(_res != OK) {
        return _res;
      }
      (*_message)->mqt_t__control_packet__unsubscribe_property_length = propertyLength;
    } else {
      (*_message)->mqt_t__control_packet__unsubscribe_property_length = NULL;
    }


                    
    // Array field (properties)
    plc4c_list* properties = NULL;
    plc4c_utils_list_create(&properties);
    if(properties == NULL) {
      return NO_MEMORY;
    }
    {
      // Length array
      uint8_t _propertiesLength = ((((propertyLength) != (NULL))) ? propertyLength : 0);
      uint8_t propertiesEndPos = plc4c_spi_read_get_pos(readBuffer) + _propertiesLength;
      while(plc4c_spi_read_get_pos(readBuffer) < propertiesEndPos) {
        plc4c_mqtt_read_write_mqt_t__property* _value = NULL;
        _res = plc4c_mqtt_read_write_mqt_t__property_parse(readBuffer, (void*) &_value);
        if(_res != OK) {
          return _res;
        }
        plc4c_utils_list_insert_head_value(properties, _value);
      }
    }
    (*_message)->mqt_t__control_packet__unsubscribe_properties = properties;


                    
    // Array field (filters)
    plc4c_list* filters = NULL;
    plc4c_utils_list_create(&filters);
    if(filters == NULL) {
      return NO_MEMORY;
    }
    {
      // Count array
      uint16_t itemCount = (uint16_t) (remainingLength) - ((plc4c_spi_read_get_pos(readBuffer) - startPos));
      for(int curItem = 0; curItem < itemCount; curItem++) {
        bool lastItem = curItem == (itemCount - 1);
        plc4c_mqtt_read_write_mqt_t__string* _value = NULL;
        _res = plc4c_mqtt_read_write_mqt_t__string_parse(readBuffer, (void*) &_value);
        if(_res != OK) {
          return _res;
        }
        plc4c_utils_list_insert_head_value(filters, _value);
      }
    }
    (*_message)->mqt_t__control_packet__unsubscribe_filters = filters;

  } else 
  if(packetType == plc4c_mqtt_read_write_mqt_t__control_packet_type_UNSUBACK) { /* MQTT_ControlPacket_UNSUBACK */
    (*_message)->_type = plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__unsuback;
                    
    // Reserved Field (Compartmentalized so the "reserved" variable can't leak)
    {
      uint8_t _reserved = 0;
      _res = plc4c_spi_read_unsigned_byte(readBuffer, 4, (uint8_t*) &_reserved);
      if(_res != OK) {
        return _res;
      }
      if(_reserved != 0x0) {
        printf("Expected constant value '%d' but got '%d' for reserved field.", 0x0, _reserved);
      }
    }


                    
    // Simple Field (remainingLength)
    uint8_t remainingLength = 0;
    _res = plc4c_spi_read_unsigned_byte(readBuffer, 8, (uint8_t*) &remainingLength);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__unsuback_remaining_length = remainingLength;


                    
    // Simple Field (packetIdentifier)
    uint16_t packetIdentifier = 0;
    _res = plc4c_spi_read_unsigned_short(readBuffer, 16, (uint16_t*) &packetIdentifier);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__unsuback_packet_identifier = packetIdentifier;


                    
    // Optional Field (propertyLength) (Can be skipped, if a given expression evaluates to false)
    uint32_t* propertyLength = NULL;
    if(((remainingLength) - ((plc4c_spi_read_get_pos(readBuffer) - startPos))) < (4)) {
      propertyLength = malloc(sizeof(uint32_t));
      if(propertyLength == NULL) {
        return NO_MEMORY;
      }
      *propertyLength = 0;
      _res = plc4c_spi_read_unsigned_int(readBuffer, 32, (uint32_t*) propertyLength);
      if(_res != OK) {
        return _res;
      }
      (*_message)->mqt_t__control_packet__unsuback_property_length = propertyLength;
    } else {
      (*_message)->mqt_t__control_packet__unsuback_property_length = NULL;
    }


                    
    // Array field (properties)
    plc4c_list* properties = NULL;
    plc4c_utils_list_create(&properties);
    if(properties == NULL) {
      return NO_MEMORY;
    }
    {
      // Length array
      uint8_t _propertiesLength = ((((propertyLength) != (NULL))) ? propertyLength : 0);
      uint8_t propertiesEndPos = plc4c_spi_read_get_pos(readBuffer) + _propertiesLength;
      while(plc4c_spi_read_get_pos(readBuffer) < propertiesEndPos) {
        plc4c_mqtt_read_write_mqt_t__property* _value = NULL;
        _res = plc4c_mqtt_read_write_mqt_t__property_parse(readBuffer, (void*) &_value);
        if(_res != OK) {
          return _res;
        }
        plc4c_utils_list_insert_head_value(properties, _value);
      }
    }
    (*_message)->mqt_t__control_packet__unsuback_properties = properties;


                    
    // Array field (results)
    plc4c_list* results = NULL;
    plc4c_utils_list_create(&results);
    if(results == NULL) {
      return NO_MEMORY;
    }
    {
      // Count array
      uint16_t itemCount = (uint16_t) (remainingLength) - ((plc4c_spi_read_get_pos(readBuffer) - startPos));
      for(int curItem = 0; curItem < itemCount; curItem++) {
        bool lastItem = curItem == (itemCount - 1);
        plc4c_mqtt_read_write_mqt_t__reason_code* _value = NULL;
        _res = plc4c_mqtt_read_write_mqt_t__reason_code_parse(readBuffer, (void*) &_value);
        if(_res != OK) {
          return _res;
        }
        plc4c_utils_list_insert_head_value(results, _value);
      }
    }
    (*_message)->mqt_t__control_packet__unsuback_results = results;

  } else 
  if(packetType == plc4c_mqtt_read_write_mqt_t__control_packet_type_PINGREQ) { /* MQTT_ControlPacket_PINGREQ */
    (*_message)->_type = plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__pingreq;
                    
    // Reserved Field (Compartmentalized so the "reserved" variable can't leak)
    {
      uint8_t _reserved = 0;
      _res = plc4c_spi_read_unsigned_byte(readBuffer, 4, (uint8_t*) &_reserved);
      if(_res != OK) {
        return _res;
      }
      if(_reserved != 0x0) {
        printf("Expected constant value '%d' but got '%d' for reserved field.", 0x0, _reserved);
      }
    }


                    
    // Simple Field (remainingLength)
    uint8_t remainingLength = 0;
    _res = plc4c_spi_read_unsigned_byte(readBuffer, 8, (uint8_t*) &remainingLength);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__pingreq_remaining_length = remainingLength;

  } else 
  if(packetType == plc4c_mqtt_read_write_mqt_t__control_packet_type_PINGRESP) { /* MQTT_ControlPacket_PINGRESP */
    (*_message)->_type = plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__pingresp;
                    
    // Reserved Field (Compartmentalized so the "reserved" variable can't leak)
    {
      uint8_t _reserved = 0;
      _res = plc4c_spi_read_unsigned_byte(readBuffer, 4, (uint8_t*) &_reserved);
      if(_res != OK) {
        return _res;
      }
      if(_reserved != 0x0) {
        printf("Expected constant value '%d' but got '%d' for reserved field.", 0x0, _reserved);
      }
    }


                    
    // Simple Field (remainingLength)
    uint8_t remainingLength = 0;
    _res = plc4c_spi_read_unsigned_byte(readBuffer, 8, (uint8_t*) &remainingLength);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__pingresp_remaining_length = remainingLength;

  } else 
  if(packetType == plc4c_mqtt_read_write_mqt_t__control_packet_type_DISCONNECT) { /* MQTT_ControlPacket_DISCONNECT */
    (*_message)->_type = plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__disconnect;
                    
    // Reserved Field (Compartmentalized so the "reserved" variable can't leak)
    {
      uint8_t _reserved = 0;
      _res = plc4c_spi_read_unsigned_byte(readBuffer, 4, (uint8_t*) &_reserved);
      if(_res != OK) {
        return _res;
      }
      if(_reserved != 0x0) {
        printf("Expected constant value '%d' but got '%d' for reserved field.", 0x0, _reserved);
      }
    }


                    
    // Simple Field (remainingLength)
    uint8_t remainingLength = 0;
    _res = plc4c_spi_read_unsigned_byte(readBuffer, 8, (uint8_t*) &remainingLength);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__disconnect_remaining_length = remainingLength;


                    
    // Simple Field (reason)
    plc4c_mqtt_read_write_mqt_t__reason_code* reason;
    _res = plc4c_mqtt_read_write_mqt_t__reason_code_parse(readBuffer, (void*) &reason);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__disconnect_reason = *reason;

  } else 
  if(packetType == plc4c_mqtt_read_write_mqt_t__control_packet_type_AUTH) { /* MQTT_ControlPacket_AUTH */
    (*_message)->_type = plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__auth;
                    
    // Reserved Field (Compartmentalized so the "reserved" variable can't leak)
    {
      uint8_t _reserved = 0;
      _res = plc4c_spi_read_unsigned_byte(readBuffer, 4, (uint8_t*) &_reserved);
      if(_res != OK) {
        return _res;
      }
      if(_reserved != 0x0) {
        printf("Expected constant value '%d' but got '%d' for reserved field.", 0x0, _reserved);
      }
    }


                    
    // Simple Field (remainingLength)
    uint8_t remainingLength = 0;
    _res = plc4c_spi_read_unsigned_byte(readBuffer, 8, (uint8_t*) &remainingLength);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__auth_remaining_length = remainingLength;


                    
    // Simple Field (reason)
    plc4c_mqtt_read_write_mqt_t__reason_code* reason;
    _res = plc4c_mqtt_read_write_mqt_t__reason_code_parse(readBuffer, (void*) &reason);
    if(_res != OK) {
      return _res;
    }
    (*_message)->mqt_t__control_packet__auth_reason = *reason;


                    
    // Optional Field (propertyLength) (Can be skipped, if a given expression evaluates to false)
    uint32_t* propertyLength = NULL;
    if(((remainingLength) - ((plc4c_spi_read_get_pos(readBuffer) - startPos))) < (4)) {
      propertyLength = malloc(sizeof(uint32_t));
      if(propertyLength == NULL) {
        return NO_MEMORY;
      }
      *propertyLength = 0;
      _res = plc4c_spi_read_unsigned_int(readBuffer, 32, (uint32_t*) propertyLength);
      if(_res != OK) {
        return _res;
      }
      (*_message)->mqt_t__control_packet__auth_property_length = propertyLength;
    } else {
      (*_message)->mqt_t__control_packet__auth_property_length = NULL;
    }


                    
    // Array field (properties)
    plc4c_list* properties = NULL;
    plc4c_utils_list_create(&properties);
    if(properties == NULL) {
      return NO_MEMORY;
    }
    {
      // Length array
      uint8_t _propertiesLength = ((((propertyLength) != (NULL))) ? propertyLength : 0);
      uint8_t propertiesEndPos = plc4c_spi_read_get_pos(readBuffer) + _propertiesLength;
      while(plc4c_spi_read_get_pos(readBuffer) < propertiesEndPos) {
        plc4c_mqtt_read_write_mqt_t__property* _value = NULL;
        _res = plc4c_mqtt_read_write_mqt_t__property_parse(readBuffer, (void*) &_value);
        if(_res != OK) {
          return _res;
        }
        plc4c_utils_list_insert_head_value(properties, _value);
      }
    }
    (*_message)->mqt_t__control_packet__auth_properties = properties;

  }

  return OK;
}

plc4c_return_code plc4c_mqtt_read_write_mqt_t__control_packet_serialize(plc4c_spi_write_buffer* writeBuffer, plc4c_mqtt_read_write_mqt_t__control_packet* _message) {
  plc4c_return_code _res = OK;

  // Enumerated Discriminator Field (packetType)
  plc4c_spi_write_unsigned_byte(writeBuffer, 4, plc4c_mqtt_read_write_mqt_t__control_packet_get_discriminator(_message->_type).packetType);

  // Switch Field (Depending of the current type, serialize the sub-type elements)
  switch(_message->_type) {
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__connect: {

      // Reserved Field
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 4, 0x0);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (remainingLength)
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 8, _message->mqt_t__control_packet__connect_remaining_length);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (protocolName)
      _res = plc4c_mqtt_read_write_mqt_t__string_serialize(writeBuffer, _message->mqt_t__control_packet__connect_protocol_name);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (protocolVersion)
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 8, _message->mqt_t__control_packet__connect_protocol_version);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (userNameFlagSet)
      _res = plc4c_spi_write_bit(writeBuffer, _message->mqt_t__control_packet__connect_user_name_flag_set);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (passwordFlagSet)
      _res = plc4c_spi_write_bit(writeBuffer, _message->mqt_t__control_packet__connect_password_flag_set);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (willRetainFlagSet)
      _res = plc4c_spi_write_bit(writeBuffer, _message->mqt_t__control_packet__connect_will_retain_flag_set);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (willQosLevel)
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 2, _message->mqt_t__control_packet__connect_will_qos_level);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (willFlagSet)
      _res = plc4c_spi_write_bit(writeBuffer, _message->mqt_t__control_packet__connect_will_flag_set);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (cleanStartFlagSet)
      _res = plc4c_spi_write_bit(writeBuffer, _message->mqt_t__control_packet__connect_clean_start_flag_set);
      if(_res != OK) {
        return _res;
      }

      // Reserved Field
      _res = plc4c_spi_write_bit(writeBuffer, false);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (keepAlive)
      _res = plc4c_spi_write_unsigned_short(writeBuffer, 16, _message->mqt_t__control_packet__connect_keep_alive);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (propertyLength)
      _res = plc4c_spi_write_unsigned_int(writeBuffer, 32, _message->mqt_t__control_packet__connect_property_length);
      if(_res != OK) {
        return _res;
      }

      // Array field (properties)
      {
        uint8_t itemCount = plc4c_utils_list_size(_message->mqt_t__control_packet__connect_properties);
        for(int curItem = 0; curItem < itemCount; curItem++) {
          bool lastItem = curItem == (itemCount - 1);
          plc4c_mqtt_read_write_mqt_t__property* _value = (plc4c_mqtt_read_write_mqt_t__property*) plc4c_utils_list_get_value(_message->mqt_t__control_packet__connect_properties, curItem);
          _res = plc4c_mqtt_read_write_mqt_t__property_serialize(writeBuffer, (void*) _value);
          if(_res != OK) {
            return _res;
          }
        }
      }

      // Simple Field (clientId)
      _res = plc4c_mqtt_read_write_mqt_t__string_serialize(writeBuffer, _message->mqt_t__control_packet__connect_client_id);
      if(_res != OK) {
        return _res;
      }

      // Optional Field (username)
      if(_message->mqt_t__control_packet__connect_username != NULL) {
        _res = plc4c_mqtt_read_write_mqt_t__string_serialize(writeBuffer, _message->mqt_t__control_packet__connect_username);
        if(_res != OK) {
          return _res;
        }
      }

      // Optional Field (password)
      if(_message->mqt_t__control_packet__connect_password != NULL) {
        _res = plc4c_mqtt_read_write_mqt_t__string_serialize(writeBuffer, _message->mqt_t__control_packet__connect_password);
        if(_res != OK) {
          return _res;
        }
      }

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__connack: {

      // Reserved Field
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 4, 0x0);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (remainingLength)
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 8, _message->mqt_t__control_packet__connack_remaining_length);
      if(_res != OK) {
        return _res;
      }

      // Reserved Field
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 7, 0x00);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (sessionPresentFlagSet)
      _res = plc4c_spi_write_bit(writeBuffer, _message->mqt_t__control_packet__connack_session_present_flag_set);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (reasonCode)
      _res = plc4c_mqtt_read_write_mqt_t__reason_code_serialize(writeBuffer, &_message->mqt_t__control_packet__connack_reason_code);
      if(_res != OK) {
        return _res;
      }

      // Optional Field (propertyLength)
      if(_message->mqt_t__control_packet__connack_property_length != NULL) {
        _res = plc4c_spi_write_unsigned_int(writeBuffer, 32, *_message->mqt_t__control_packet__connack_property_length);
        if(_res != OK) {
          return _res;
        }
      }

      // Array field (properties)
      {
        uint8_t itemCount = plc4c_utils_list_size(_message->mqt_t__control_packet__connack_properties);
        for(int curItem = 0; curItem < itemCount; curItem++) {
          bool lastItem = curItem == (itemCount - 1);
          plc4c_mqtt_read_write_mqt_t__property* _value = (plc4c_mqtt_read_write_mqt_t__property*) plc4c_utils_list_get_value(_message->mqt_t__control_packet__connack_properties, curItem);
          _res = plc4c_mqtt_read_write_mqt_t__property_serialize(writeBuffer, (void*) _value);
          if(_res != OK) {
            return _res;
          }
        }
      }

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__publish: {

      // Simple Field (dup)
      _res = plc4c_spi_write_bit(writeBuffer, _message->mqt_t__control_packet__publish_dup);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (qos)
      _res = plc4c_mqtt_read_write_mqt_t__qos_serialize(writeBuffer, &_message->mqt_t__control_packet__publish_qos);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (retain)
      _res = plc4c_spi_write_bit(writeBuffer, _message->mqt_t__control_packet__publish_retain);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (remainingLength)
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 8, _message->mqt_t__control_packet__publish_remaining_length);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (topicName)
      _res = plc4c_mqtt_read_write_mqt_t__string_serialize(writeBuffer, _message->mqt_t__control_packet__publish_topic_name);
      if(_res != OK) {
        return _res;
      }

      // Optional Field (packetIdentifier)
      if(_message->mqt_t__control_packet__publish_packet_identifier != NULL) {
        _res = plc4c_spi_write_unsigned_short(writeBuffer, 16, *_message->mqt_t__control_packet__publish_packet_identifier);
        if(_res != OK) {
          return _res;
        }
      }

      // Optional Field (propertyLength)
      if(_message->mqt_t__control_packet__publish_property_length != NULL) {
        _res = plc4c_spi_write_unsigned_int(writeBuffer, 32, *_message->mqt_t__control_packet__publish_property_length);
        if(_res != OK) {
          return _res;
        }
      }

      // Array field (properties)
      {
        uint8_t itemCount = plc4c_utils_list_size(_message->mqt_t__control_packet__publish_properties);
        for(int curItem = 0; curItem < itemCount; curItem++) {
          bool lastItem = curItem == (itemCount - 1);
          plc4c_mqtt_read_write_mqt_t__property* _value = (plc4c_mqtt_read_write_mqt_t__property*) plc4c_utils_list_get_value(_message->mqt_t__control_packet__publish_properties, curItem);
          _res = plc4c_mqtt_read_write_mqt_t__property_serialize(writeBuffer, (void*) _value);
          if(_res != OK) {
            return _res;
          }
        }
      }

      // Array field (payload)
      {
        uint8_t itemCount = plc4c_utils_list_size(_message->mqt_t__control_packet__publish_payload);
        for(int curItem = 0; curItem < itemCount; curItem++) {

          char* _value = (char*) plc4c_utils_list_get_value(_message->mqt_t__control_packet__publish_payload, curItem);
          plc4c_spi_write_char(writeBuffer, *_value);
        }
      }

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__puback: {

      // Reserved Field
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 4, 0x0);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (remainingLength)
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 8, _message->mqt_t__control_packet__puback_remaining_length);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (packetIdentifier)
      _res = plc4c_spi_write_unsigned_short(writeBuffer, 16, _message->mqt_t__control_packet__puback_packet_identifier);
      if(_res != OK) {
        return _res;
      }

      // Optional Field (reasonCode)
      if(_message->mqt_t__control_packet__puback_reason_code != NULL) {
        _res = plc4c_mqtt_read_write_mqt_t__reason_code_serialize(writeBuffer, _message->mqt_t__control_packet__puback_reason_code);
        if(_res != OK) {
          return _res;
        }
      }

      // Optional Field (propertyLength)
      if(_message->mqt_t__control_packet__puback_property_length != NULL) {
        _res = plc4c_spi_write_unsigned_int(writeBuffer, 32, *_message->mqt_t__control_packet__puback_property_length);
        if(_res != OK) {
          return _res;
        }
      }

      // Array field (properties)
      {
        uint8_t itemCount = plc4c_utils_list_size(_message->mqt_t__control_packet__puback_properties);
        for(int curItem = 0; curItem < itemCount; curItem++) {
          bool lastItem = curItem == (itemCount - 1);
          plc4c_mqtt_read_write_mqt_t__property* _value = (plc4c_mqtt_read_write_mqt_t__property*) plc4c_utils_list_get_value(_message->mqt_t__control_packet__puback_properties, curItem);
          _res = plc4c_mqtt_read_write_mqt_t__property_serialize(writeBuffer, (void*) _value);
          if(_res != OK) {
            return _res;
          }
        }
      }

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__pubrec: {

      // Reserved Field
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 4, 0x0);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (remainingLength)
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 8, _message->mqt_t__control_packet__pubrec_remaining_length);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (packetIdentifier)
      _res = plc4c_spi_write_unsigned_short(writeBuffer, 16, _message->mqt_t__control_packet__pubrec_packet_identifier);
      if(_res != OK) {
        return _res;
      }

      // Optional Field (reasonCode)
      if(_message->mqt_t__control_packet__pubrec_reason_code != NULL) {
        _res = plc4c_mqtt_read_write_mqt_t__reason_code_serialize(writeBuffer, _message->mqt_t__control_packet__pubrec_reason_code);
        if(_res != OK) {
          return _res;
        }
      }

      // Optional Field (propertyLength)
      if(_message->mqt_t__control_packet__pubrec_property_length != NULL) {
        _res = plc4c_spi_write_unsigned_int(writeBuffer, 32, *_message->mqt_t__control_packet__pubrec_property_length);
        if(_res != OK) {
          return _res;
        }
      }

      // Array field (properties)
      {
        uint8_t itemCount = plc4c_utils_list_size(_message->mqt_t__control_packet__pubrec_properties);
        for(int curItem = 0; curItem < itemCount; curItem++) {
          bool lastItem = curItem == (itemCount - 1);
          plc4c_mqtt_read_write_mqt_t__property* _value = (plc4c_mqtt_read_write_mqt_t__property*) plc4c_utils_list_get_value(_message->mqt_t__control_packet__pubrec_properties, curItem);
          _res = plc4c_mqtt_read_write_mqt_t__property_serialize(writeBuffer, (void*) _value);
          if(_res != OK) {
            return _res;
          }
        }
      }

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__pubrel: {

      // Reserved Field
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 4, 0x0);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (remainingLength)
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 8, _message->mqt_t__control_packet__pubrel_remaining_length);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (packetIdentifier)
      _res = plc4c_spi_write_unsigned_short(writeBuffer, 16, _message->mqt_t__control_packet__pubrel_packet_identifier);
      if(_res != OK) {
        return _res;
      }

      // Optional Field (reasonCode)
      if(_message->mqt_t__control_packet__pubrel_reason_code != NULL) {
        _res = plc4c_mqtt_read_write_mqt_t__reason_code_serialize(writeBuffer, _message->mqt_t__control_packet__pubrel_reason_code);
        if(_res != OK) {
          return _res;
        }
      }

      // Optional Field (propertyLength)
      if(_message->mqt_t__control_packet__pubrel_property_length != NULL) {
        _res = plc4c_spi_write_unsigned_int(writeBuffer, 32, *_message->mqt_t__control_packet__pubrel_property_length);
        if(_res != OK) {
          return _res;
        }
      }

      // Array field (properties)
      {
        uint8_t itemCount = plc4c_utils_list_size(_message->mqt_t__control_packet__pubrel_properties);
        for(int curItem = 0; curItem < itemCount; curItem++) {
          bool lastItem = curItem == (itemCount - 1);
          plc4c_mqtt_read_write_mqt_t__property* _value = (plc4c_mqtt_read_write_mqt_t__property*) plc4c_utils_list_get_value(_message->mqt_t__control_packet__pubrel_properties, curItem);
          _res = plc4c_mqtt_read_write_mqt_t__property_serialize(writeBuffer, (void*) _value);
          if(_res != OK) {
            return _res;
          }
        }
      }

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__pubcomp: {

      // Reserved Field
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 4, 0x0);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (remainingLength)
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 8, _message->mqt_t__control_packet__pubcomp_remaining_length);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (packetIdentifier)
      _res = plc4c_spi_write_unsigned_short(writeBuffer, 16, _message->mqt_t__control_packet__pubcomp_packet_identifier);
      if(_res != OK) {
        return _res;
      }

      // Optional Field (reasonCode)
      if(_message->mqt_t__control_packet__pubcomp_reason_code != NULL) {
        _res = plc4c_mqtt_read_write_mqt_t__reason_code_serialize(writeBuffer, _message->mqt_t__control_packet__pubcomp_reason_code);
        if(_res != OK) {
          return _res;
        }
      }

      // Optional Field (propertyLength)
      if(_message->mqt_t__control_packet__pubcomp_property_length != NULL) {
        _res = plc4c_spi_write_unsigned_int(writeBuffer, 32, *_message->mqt_t__control_packet__pubcomp_property_length);
        if(_res != OK) {
          return _res;
        }
      }

      // Array field (properties)
      {
        uint8_t itemCount = plc4c_utils_list_size(_message->mqt_t__control_packet__pubcomp_properties);
        for(int curItem = 0; curItem < itemCount; curItem++) {
          bool lastItem = curItem == (itemCount - 1);
          plc4c_mqtt_read_write_mqt_t__property* _value = (plc4c_mqtt_read_write_mqt_t__property*) plc4c_utils_list_get_value(_message->mqt_t__control_packet__pubcomp_properties, curItem);
          _res = plc4c_mqtt_read_write_mqt_t__property_serialize(writeBuffer, (void*) _value);
          if(_res != OK) {
            return _res;
          }
        }
      }

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__subscribe: {

      // Reserved Field
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 4, 0x0);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (remainingLength)
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 8, _message->mqt_t__control_packet__subscribe_remaining_length);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (packetIdentifier)
      _res = plc4c_spi_write_unsigned_short(writeBuffer, 16, _message->mqt_t__control_packet__subscribe_packet_identifier);
      if(_res != OK) {
        return _res;
      }

      // Optional Field (propertyLength)
      if(_message->mqt_t__control_packet__subscribe_property_length != NULL) {
        _res = plc4c_spi_write_unsigned_int(writeBuffer, 32, *_message->mqt_t__control_packet__subscribe_property_length);
        if(_res != OK) {
          return _res;
        }
      }

      // Array field (properties)
      {
        uint8_t itemCount = plc4c_utils_list_size(_message->mqt_t__control_packet__subscribe_properties);
        for(int curItem = 0; curItem < itemCount; curItem++) {
          bool lastItem = curItem == (itemCount - 1);
          plc4c_mqtt_read_write_mqt_t__property* _value = (plc4c_mqtt_read_write_mqt_t__property*) plc4c_utils_list_get_value(_message->mqt_t__control_packet__subscribe_properties, curItem);
          _res = plc4c_mqtt_read_write_mqt_t__property_serialize(writeBuffer, (void*) _value);
          if(_res != OK) {
            return _res;
          }
        }
      }

      // Array field (filters)
      {
        uint8_t itemCount = plc4c_utils_list_size(_message->mqt_t__control_packet__subscribe_filters);
        for(int curItem = 0; curItem < itemCount; curItem++) {
          bool lastItem = curItem == (itemCount - 1);
          plc4c_mqtt_read_write_filter* _value = (plc4c_mqtt_read_write_filter*) plc4c_utils_list_get_value(_message->mqt_t__control_packet__subscribe_filters, curItem);
          _res = plc4c_mqtt_read_write_filter_serialize(writeBuffer, (void*) _value);
          if(_res != OK) {
            return _res;
          }
        }
      }

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__suback: {

      // Reserved Field
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 4, 0x0);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (remainingLength)
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 8, _message->mqt_t__control_packet__suback_remaining_length);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (packetIdentifier)
      _res = plc4c_spi_write_unsigned_short(writeBuffer, 16, _message->mqt_t__control_packet__suback_packet_identifier);
      if(_res != OK) {
        return _res;
      }

      // Optional Field (propertyLength)
      if(_message->mqt_t__control_packet__suback_property_length != NULL) {
        _res = plc4c_spi_write_unsigned_int(writeBuffer, 32, *_message->mqt_t__control_packet__suback_property_length);
        if(_res != OK) {
          return _res;
        }
      }

      // Array field (properties)
      {
        uint8_t itemCount = plc4c_utils_list_size(_message->mqt_t__control_packet__suback_properties);
        for(int curItem = 0; curItem < itemCount; curItem++) {
          bool lastItem = curItem == (itemCount - 1);
          plc4c_mqtt_read_write_mqt_t__property* _value = (plc4c_mqtt_read_write_mqt_t__property*) plc4c_utils_list_get_value(_message->mqt_t__control_packet__suback_properties, curItem);
          _res = plc4c_mqtt_read_write_mqt_t__property_serialize(writeBuffer, (void*) _value);
          if(_res != OK) {
            return _res;
          }
        }
      }

      // Array field (results)
      {
        uint8_t itemCount = plc4c_utils_list_size(_message->mqt_t__control_packet__suback_results);
        for(int curItem = 0; curItem < itemCount; curItem++) {
          bool lastItem = curItem == (itemCount - 1);
          plc4c_mqtt_read_write_mqt_t__reason_code* _value = (plc4c_mqtt_read_write_mqt_t__reason_code*) plc4c_utils_list_get_value(_message->mqt_t__control_packet__suback_results, curItem);
          _res = plc4c_mqtt_read_write_mqt_t__reason_code_serialize(writeBuffer, (void*) _value);
          if(_res != OK) {
            return _res;
          }
        }
      }

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__unsubscribe: {

      // Reserved Field
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 4, 0x0);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (remainingLength)
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 8, _message->mqt_t__control_packet__unsubscribe_remaining_length);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (packetIdentifier)
      _res = plc4c_spi_write_unsigned_short(writeBuffer, 16, _message->mqt_t__control_packet__unsubscribe_packet_identifier);
      if(_res != OK) {
        return _res;
      }

      // Optional Field (propertyLength)
      if(_message->mqt_t__control_packet__unsubscribe_property_length != NULL) {
        _res = plc4c_spi_write_unsigned_int(writeBuffer, 32, *_message->mqt_t__control_packet__unsubscribe_property_length);
        if(_res != OK) {
          return _res;
        }
      }

      // Array field (properties)
      {
        uint8_t itemCount = plc4c_utils_list_size(_message->mqt_t__control_packet__unsubscribe_properties);
        for(int curItem = 0; curItem < itemCount; curItem++) {
          bool lastItem = curItem == (itemCount - 1);
          plc4c_mqtt_read_write_mqt_t__property* _value = (plc4c_mqtt_read_write_mqt_t__property*) plc4c_utils_list_get_value(_message->mqt_t__control_packet__unsubscribe_properties, curItem);
          _res = plc4c_mqtt_read_write_mqt_t__property_serialize(writeBuffer, (void*) _value);
          if(_res != OK) {
            return _res;
          }
        }
      }

      // Array field (filters)
      {
        uint8_t itemCount = plc4c_utils_list_size(_message->mqt_t__control_packet__unsubscribe_filters);
        for(int curItem = 0; curItem < itemCount; curItem++) {
          bool lastItem = curItem == (itemCount - 1);
          plc4c_mqtt_read_write_mqt_t__string* _value = (plc4c_mqtt_read_write_mqt_t__string*) plc4c_utils_list_get_value(_message->mqt_t__control_packet__unsubscribe_filters, curItem);
          _res = plc4c_mqtt_read_write_mqt_t__string_serialize(writeBuffer, (void*) _value);
          if(_res != OK) {
            return _res;
          }
        }
      }

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__unsuback: {

      // Reserved Field
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 4, 0x0);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (remainingLength)
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 8, _message->mqt_t__control_packet__unsuback_remaining_length);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (packetIdentifier)
      _res = plc4c_spi_write_unsigned_short(writeBuffer, 16, _message->mqt_t__control_packet__unsuback_packet_identifier);
      if(_res != OK) {
        return _res;
      }

      // Optional Field (propertyLength)
      if(_message->mqt_t__control_packet__unsuback_property_length != NULL) {
        _res = plc4c_spi_write_unsigned_int(writeBuffer, 32, *_message->mqt_t__control_packet__unsuback_property_length);
        if(_res != OK) {
          return _res;
        }
      }

      // Array field (properties)
      {
        uint8_t itemCount = plc4c_utils_list_size(_message->mqt_t__control_packet__unsuback_properties);
        for(int curItem = 0; curItem < itemCount; curItem++) {
          bool lastItem = curItem == (itemCount - 1);
          plc4c_mqtt_read_write_mqt_t__property* _value = (plc4c_mqtt_read_write_mqt_t__property*) plc4c_utils_list_get_value(_message->mqt_t__control_packet__unsuback_properties, curItem);
          _res = plc4c_mqtt_read_write_mqt_t__property_serialize(writeBuffer, (void*) _value);
          if(_res != OK) {
            return _res;
          }
        }
      }

      // Array field (results)
      {
        uint8_t itemCount = plc4c_utils_list_size(_message->mqt_t__control_packet__unsuback_results);
        for(int curItem = 0; curItem < itemCount; curItem++) {
          bool lastItem = curItem == (itemCount - 1);
          plc4c_mqtt_read_write_mqt_t__reason_code* _value = (plc4c_mqtt_read_write_mqt_t__reason_code*) plc4c_utils_list_get_value(_message->mqt_t__control_packet__unsuback_results, curItem);
          _res = plc4c_mqtt_read_write_mqt_t__reason_code_serialize(writeBuffer, (void*) _value);
          if(_res != OK) {
            return _res;
          }
        }
      }

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__pingreq: {

      // Reserved Field
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 4, 0x0);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (remainingLength)
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 8, _message->mqt_t__control_packet__pingreq_remaining_length);
      if(_res != OK) {
        return _res;
      }

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__pingresp: {

      // Reserved Field
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 4, 0x0);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (remainingLength)
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 8, _message->mqt_t__control_packet__pingresp_remaining_length);
      if(_res != OK) {
        return _res;
      }

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__disconnect: {

      // Reserved Field
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 4, 0x0);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (remainingLength)
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 8, _message->mqt_t__control_packet__disconnect_remaining_length);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (reason)
      _res = plc4c_mqtt_read_write_mqt_t__reason_code_serialize(writeBuffer, &_message->mqt_t__control_packet__disconnect_reason);
      if(_res != OK) {
        return _res;
      }

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__auth: {

      // Reserved Field
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 4, 0x0);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (remainingLength)
      _res = plc4c_spi_write_unsigned_byte(writeBuffer, 8, _message->mqt_t__control_packet__auth_remaining_length);
      if(_res != OK) {
        return _res;
      }

      // Simple Field (reason)
      _res = plc4c_mqtt_read_write_mqt_t__reason_code_serialize(writeBuffer, &_message->mqt_t__control_packet__auth_reason);
      if(_res != OK) {
        return _res;
      }

      // Optional Field (propertyLength)
      if(_message->mqt_t__control_packet__auth_property_length != NULL) {
        _res = plc4c_spi_write_unsigned_int(writeBuffer, 32, *_message->mqt_t__control_packet__auth_property_length);
        if(_res != OK) {
          return _res;
        }
      }

      // Array field (properties)
      {
        uint8_t itemCount = plc4c_utils_list_size(_message->mqt_t__control_packet__auth_properties);
        for(int curItem = 0; curItem < itemCount; curItem++) {
          bool lastItem = curItem == (itemCount - 1);
          plc4c_mqtt_read_write_mqt_t__property* _value = (plc4c_mqtt_read_write_mqt_t__property*) plc4c_utils_list_get_value(_message->mqt_t__control_packet__auth_properties, curItem);
          _res = plc4c_mqtt_read_write_mqt_t__property_serialize(writeBuffer, (void*) _value);
          if(_res != OK) {
            return _res;
          }
        }
      }

      break;
    }
  }

  return OK;
}

uint16_t plc4c_mqtt_read_write_mqt_t__control_packet_length_in_bytes(plc4c_mqtt_read_write_mqt_t__control_packet* _message) {
  return plc4c_mqtt_read_write_mqt_t__control_packet_length_in_bits(_message) / 8;
}

uint16_t plc4c_mqtt_read_write_mqt_t__control_packet_length_in_bits(plc4c_mqtt_read_write_mqt_t__control_packet* _message) {
  uint16_t lengthInBits = 0;

  // Discriminator Field (packetType)
  lengthInBits += 4;

  // Depending of the current type, add the length of sub-type elements ...
  switch(_message->_type) {
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__connect: {

      // Reserved Field (reserved)
      lengthInBits += 4;


      // Simple field (remainingLength)
      lengthInBits += 8;


      // Simple field (protocolName)
      lengthInBits += plc4c_mqtt_read_write_mqt_t__string_length_in_bits(_message->mqt_t__control_packet__connect_protocol_name);


      // Simple field (protocolVersion)
      lengthInBits += 8;


      // Simple field (userNameFlagSet)
      lengthInBits += 1;


      // Simple field (passwordFlagSet)
      lengthInBits += 1;


      // Simple field (willRetainFlagSet)
      lengthInBits += 1;


      // Simple field (willQosLevel)
      lengthInBits += 2;


      // Simple field (willFlagSet)
      lengthInBits += 1;


      // Simple field (cleanStartFlagSet)
      lengthInBits += 1;


      // Reserved Field (reserved)
      lengthInBits += 1;


      // Simple field (keepAlive)
      lengthInBits += 16;


      // Simple field (propertyLength)
      lengthInBits += 32;


      // Array field
      if(_message->mqt_t__control_packet__connect_properties != NULL) {
        plc4c_list_element* curElement = _message->mqt_t__control_packet__connect_properties->tail;
        while (curElement != NULL) {
          lengthInBits += plc4c_mqtt_read_write_mqt_t__property_length_in_bits((plc4c_mqtt_read_write_mqt_t__property*) curElement->value);
          curElement = curElement->next;
        }
      }


      // Simple field (clientId)
      lengthInBits += plc4c_mqtt_read_write_mqt_t__string_length_in_bits(_message->mqt_t__control_packet__connect_client_id);


      // Optional Field (username)
      if(_message->mqt_t__control_packet__connect_username != NULL) {
        lengthInBits += plc4c_mqtt_read_write_mqt_t__string_length_in_bits(_message->mqt_t__control_packet__connect_username);
      }


      // Optional Field (password)
      if(_message->mqt_t__control_packet__connect_password != NULL) {
        lengthInBits += plc4c_mqtt_read_write_mqt_t__string_length_in_bits(_message->mqt_t__control_packet__connect_password);
      }

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__connack: {

      // Reserved Field (reserved)
      lengthInBits += 4;


      // Simple field (remainingLength)
      lengthInBits += 8;


      // Reserved Field (reserved)
      lengthInBits += 7;


      // Simple field (sessionPresentFlagSet)
      lengthInBits += 1;


      // Simple field (reasonCode)
      lengthInBits += plc4c_mqtt_read_write_mqt_t__reason_code_length_in_bits(&_message->mqt_t__control_packet__connack_reason_code);


      // Optional Field (propertyLength)
      if(_message->mqt_t__control_packet__connack_property_length != NULL) {
        lengthInBits += 32;
      }


      // Array field
      if(_message->mqt_t__control_packet__connack_properties != NULL) {
        plc4c_list_element* curElement = _message->mqt_t__control_packet__connack_properties->tail;
        while (curElement != NULL) {
          lengthInBits += plc4c_mqtt_read_write_mqt_t__property_length_in_bits((plc4c_mqtt_read_write_mqt_t__property*) curElement->value);
          curElement = curElement->next;
        }
      }

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__publish: {

      // Simple field (dup)
      lengthInBits += 1;


      // Simple field (qos)
      lengthInBits += plc4c_mqtt_read_write_mqt_t__qos_length_in_bits(&_message->mqt_t__control_packet__publish_qos);


      // Simple field (retain)
      lengthInBits += 1;


      // Simple field (remainingLength)
      lengthInBits += 8;


      // Simple field (topicName)
      lengthInBits += plc4c_mqtt_read_write_mqt_t__string_length_in_bits(_message->mqt_t__control_packet__publish_topic_name);


      // Optional Field (packetIdentifier)
      if(_message->mqt_t__control_packet__publish_packet_identifier != NULL) {
        lengthInBits += 16;
      }


      // Optional Field (propertyLength)
      if(_message->mqt_t__control_packet__publish_property_length != NULL) {
        lengthInBits += 32;
      }


      // Array field
      if(_message->mqt_t__control_packet__publish_properties != NULL) {
        plc4c_list_element* curElement = _message->mqt_t__control_packet__publish_properties->tail;
        while (curElement != NULL) {
          lengthInBits += plc4c_mqtt_read_write_mqt_t__property_length_in_bits((plc4c_mqtt_read_write_mqt_t__property*) curElement->value);
          curElement = curElement->next;
        }
      }


      // Array field
      lengthInBits += 8 * plc4c_utils_list_size(_message->mqt_t__control_packet__publish_payload);

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__puback: {

      // Reserved Field (reserved)
      lengthInBits += 4;


      // Simple field (remainingLength)
      lengthInBits += 8;


      // Simple field (packetIdentifier)
      lengthInBits += 16;


      // Optional Field (reasonCode)
      if(_message->mqt_t__control_packet__puback_reason_code != NULL) {
        lengthInBits += plc4c_mqtt_read_write_mqt_t__reason_code_length_in_bits(_message->mqt_t__control_packet__puback_reason_code);
      }


      // Optional Field (propertyLength)
      if(_message->mqt_t__control_packet__puback_property_length != NULL) {
        lengthInBits += 32;
      }


      // Array field
      if(_message->mqt_t__control_packet__puback_properties != NULL) {
        plc4c_list_element* curElement = _message->mqt_t__control_packet__puback_properties->tail;
        while (curElement != NULL) {
          lengthInBits += plc4c_mqtt_read_write_mqt_t__property_length_in_bits((plc4c_mqtt_read_write_mqt_t__property*) curElement->value);
          curElement = curElement->next;
        }
      }

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__pubrec: {

      // Reserved Field (reserved)
      lengthInBits += 4;


      // Simple field (remainingLength)
      lengthInBits += 8;


      // Simple field (packetIdentifier)
      lengthInBits += 16;


      // Optional Field (reasonCode)
      if(_message->mqt_t__control_packet__pubrec_reason_code != NULL) {
        lengthInBits += plc4c_mqtt_read_write_mqt_t__reason_code_length_in_bits(_message->mqt_t__control_packet__pubrec_reason_code);
      }


      // Optional Field (propertyLength)
      if(_message->mqt_t__control_packet__pubrec_property_length != NULL) {
        lengthInBits += 32;
      }


      // Array field
      if(_message->mqt_t__control_packet__pubrec_properties != NULL) {
        plc4c_list_element* curElement = _message->mqt_t__control_packet__pubrec_properties->tail;
        while (curElement != NULL) {
          lengthInBits += plc4c_mqtt_read_write_mqt_t__property_length_in_bits((plc4c_mqtt_read_write_mqt_t__property*) curElement->value);
          curElement = curElement->next;
        }
      }

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__pubrel: {

      // Reserved Field (reserved)
      lengthInBits += 4;


      // Simple field (remainingLength)
      lengthInBits += 8;


      // Simple field (packetIdentifier)
      lengthInBits += 16;


      // Optional Field (reasonCode)
      if(_message->mqt_t__control_packet__pubrel_reason_code != NULL) {
        lengthInBits += plc4c_mqtt_read_write_mqt_t__reason_code_length_in_bits(_message->mqt_t__control_packet__pubrel_reason_code);
      }


      // Optional Field (propertyLength)
      if(_message->mqt_t__control_packet__pubrel_property_length != NULL) {
        lengthInBits += 32;
      }


      // Array field
      if(_message->mqt_t__control_packet__pubrel_properties != NULL) {
        plc4c_list_element* curElement = _message->mqt_t__control_packet__pubrel_properties->tail;
        while (curElement != NULL) {
          lengthInBits += plc4c_mqtt_read_write_mqt_t__property_length_in_bits((plc4c_mqtt_read_write_mqt_t__property*) curElement->value);
          curElement = curElement->next;
        }
      }

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__pubcomp: {

      // Reserved Field (reserved)
      lengthInBits += 4;


      // Simple field (remainingLength)
      lengthInBits += 8;


      // Simple field (packetIdentifier)
      lengthInBits += 16;


      // Optional Field (reasonCode)
      if(_message->mqt_t__control_packet__pubcomp_reason_code != NULL) {
        lengthInBits += plc4c_mqtt_read_write_mqt_t__reason_code_length_in_bits(_message->mqt_t__control_packet__pubcomp_reason_code);
      }


      // Optional Field (propertyLength)
      if(_message->mqt_t__control_packet__pubcomp_property_length != NULL) {
        lengthInBits += 32;
      }


      // Array field
      if(_message->mqt_t__control_packet__pubcomp_properties != NULL) {
        plc4c_list_element* curElement = _message->mqt_t__control_packet__pubcomp_properties->tail;
        while (curElement != NULL) {
          lengthInBits += plc4c_mqtt_read_write_mqt_t__property_length_in_bits((plc4c_mqtt_read_write_mqt_t__property*) curElement->value);
          curElement = curElement->next;
        }
      }

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__subscribe: {

      // Reserved Field (reserved)
      lengthInBits += 4;


      // Simple field (remainingLength)
      lengthInBits += 8;


      // Simple field (packetIdentifier)
      lengthInBits += 16;


      // Optional Field (propertyLength)
      if(_message->mqt_t__control_packet__subscribe_property_length != NULL) {
        lengthInBits += 32;
      }


      // Array field
      if(_message->mqt_t__control_packet__subscribe_properties != NULL) {
        plc4c_list_element* curElement = _message->mqt_t__control_packet__subscribe_properties->tail;
        while (curElement != NULL) {
          lengthInBits += plc4c_mqtt_read_write_mqt_t__property_length_in_bits((plc4c_mqtt_read_write_mqt_t__property*) curElement->value);
          curElement = curElement->next;
        }
      }


      // Array field
      if(_message->mqt_t__control_packet__subscribe_filters != NULL) {
        plc4c_list_element* curElement = _message->mqt_t__control_packet__subscribe_filters->tail;
        while (curElement != NULL) {
          lengthInBits += plc4c_mqtt_read_write_filter_length_in_bits((plc4c_mqtt_read_write_filter*) curElement->value);
          curElement = curElement->next;
        }
      }

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__suback: {

      // Reserved Field (reserved)
      lengthInBits += 4;


      // Simple field (remainingLength)
      lengthInBits += 8;


      // Simple field (packetIdentifier)
      lengthInBits += 16;


      // Optional Field (propertyLength)
      if(_message->mqt_t__control_packet__suback_property_length != NULL) {
        lengthInBits += 32;
      }


      // Array field
      if(_message->mqt_t__control_packet__suback_properties != NULL) {
        plc4c_list_element* curElement = _message->mqt_t__control_packet__suback_properties->tail;
        while (curElement != NULL) {
          lengthInBits += plc4c_mqtt_read_write_mqt_t__property_length_in_bits((plc4c_mqtt_read_write_mqt_t__property*) curElement->value);
          curElement = curElement->next;
        }
      }


      // Array field
      if(_message->mqt_t__control_packet__suback_results != NULL) {
        plc4c_list_element* curElement = _message->mqt_t__control_packet__suback_results->tail;
        while (curElement != NULL) {
          lengthInBits += plc4c_mqtt_read_write_mqt_t__reason_code_length_in_bits((plc4c_mqtt_read_write_mqt_t__reason_code*) curElement->value);
          curElement = curElement->next;
        }
      }

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__unsubscribe: {

      // Reserved Field (reserved)
      lengthInBits += 4;


      // Simple field (remainingLength)
      lengthInBits += 8;


      // Simple field (packetIdentifier)
      lengthInBits += 16;


      // Optional Field (propertyLength)
      if(_message->mqt_t__control_packet__unsubscribe_property_length != NULL) {
        lengthInBits += 32;
      }


      // Array field
      if(_message->mqt_t__control_packet__unsubscribe_properties != NULL) {
        plc4c_list_element* curElement = _message->mqt_t__control_packet__unsubscribe_properties->tail;
        while (curElement != NULL) {
          lengthInBits += plc4c_mqtt_read_write_mqt_t__property_length_in_bits((plc4c_mqtt_read_write_mqt_t__property*) curElement->value);
          curElement = curElement->next;
        }
      }


      // Array field
      if(_message->mqt_t__control_packet__unsubscribe_filters != NULL) {
        plc4c_list_element* curElement = _message->mqt_t__control_packet__unsubscribe_filters->tail;
        while (curElement != NULL) {
          lengthInBits += plc4c_mqtt_read_write_mqt_t__string_length_in_bits((plc4c_mqtt_read_write_mqt_t__string*) curElement->value);
          curElement = curElement->next;
        }
      }

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__unsuback: {

      // Reserved Field (reserved)
      lengthInBits += 4;


      // Simple field (remainingLength)
      lengthInBits += 8;


      // Simple field (packetIdentifier)
      lengthInBits += 16;


      // Optional Field (propertyLength)
      if(_message->mqt_t__control_packet__unsuback_property_length != NULL) {
        lengthInBits += 32;
      }


      // Array field
      if(_message->mqt_t__control_packet__unsuback_properties != NULL) {
        plc4c_list_element* curElement = _message->mqt_t__control_packet__unsuback_properties->tail;
        while (curElement != NULL) {
          lengthInBits += plc4c_mqtt_read_write_mqt_t__property_length_in_bits((plc4c_mqtt_read_write_mqt_t__property*) curElement->value);
          curElement = curElement->next;
        }
      }


      // Array field
      if(_message->mqt_t__control_packet__unsuback_results != NULL) {
        plc4c_list_element* curElement = _message->mqt_t__control_packet__unsuback_results->tail;
        while (curElement != NULL) {
          lengthInBits += plc4c_mqtt_read_write_mqt_t__reason_code_length_in_bits((plc4c_mqtt_read_write_mqt_t__reason_code*) curElement->value);
          curElement = curElement->next;
        }
      }

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__pingreq: {

      // Reserved Field (reserved)
      lengthInBits += 4;


      // Simple field (remainingLength)
      lengthInBits += 8;

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__pingresp: {

      // Reserved Field (reserved)
      lengthInBits += 4;


      // Simple field (remainingLength)
      lengthInBits += 8;

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__disconnect: {

      // Reserved Field (reserved)
      lengthInBits += 4;


      // Simple field (remainingLength)
      lengthInBits += 8;


      // Simple field (reason)
      lengthInBits += plc4c_mqtt_read_write_mqt_t__reason_code_length_in_bits(&_message->mqt_t__control_packet__disconnect_reason);

      break;
    }
    case plc4c_mqtt_read_write_mqt_t__control_packet_type_plc4c_mqtt_read_write_mqt_t__control_packet__auth: {

      // Reserved Field (reserved)
      lengthInBits += 4;


      // Simple field (remainingLength)
      lengthInBits += 8;


      // Simple field (reason)
      lengthInBits += plc4c_mqtt_read_write_mqt_t__reason_code_length_in_bits(&_message->mqt_t__control_packet__auth_reason);


      // Optional Field (propertyLength)
      if(_message->mqt_t__control_packet__auth_property_length != NULL) {
        lengthInBits += 32;
      }


      // Array field
      if(_message->mqt_t__control_packet__auth_properties != NULL) {
        plc4c_list_element* curElement = _message->mqt_t__control_packet__auth_properties->tail;
        while (curElement != NULL) {
          lengthInBits += plc4c_mqtt_read_write_mqt_t__property_length_in_bits((plc4c_mqtt_read_write_mqt_t__property*) curElement->value);
          curElement = curElement->next;
        }
      }

      break;
    }
  }

  return lengthInBits;
}

